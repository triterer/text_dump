Блокировки
========================

## Виды блокировок
### Блокировка поддерева индексов
Поскольку все столбцы id в таблицах ссылок на документы проиндексированны в формате бинарных деревьев существует возможность блокировать поддерево для эффективной блокировки. При блокировке в дереве соответсующий узел помечается как заблокированный. Любые поиски пытающиеся провести поиск этого узла или глубже ожидают его разблокировки.


### Блокировка чтения строки
При чтении в таблице у троки инкрементируется значение чтения в таблице. При окончании декрементируется

### Блокировка записи строки
Перед записью строка в таблице помечается как готовящаяся к записи в таблице. В этом состоянии клиент ждёт обнуления числа чтений. Добавление новых чтений в этом состоянии невозможно.

Когда все чтения завершены, строка блокируется для записи. По окончанию изменений разблокируется.

### Блокировка таблицы
При изменениях затрагивающих всю таблицу она помечается как готовящаяся к записи. В этом состоянии клиент ждёт обнуления числа чтений и записей строк. Добавление новых чтений и заисей строк в этом состоянии невозможно.

Когда все операции над строками завершены, таблица блокируется и операция над ней производится. После этого таблица разблокируется.




## Заблокированное состояние при использовании блокировок
### В пределах сервера
#### Ошибка на клиенте во время редактирования записи
1. Клиент получает метаданные таблицы от базы метаданных таблиц
2. Клиент помечает в базе данных таблицы файл как заблокированный для изменений
3. Клиент получает метаданные файла который собирается изменить от базы данных данной таблицы
4. Клиент измет файл
5. Ошибка на клиенте не даёт ему возможности завершить процесс

Файл остаётся в заблокированном состоянии. Другие клиенты, которые будут пытаться получить доступ к файлу будут ждать его разблокировки, которая никогда не наступит

Схема работы:

![petri_db_write_failure](../media/petri_db-%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D1%8C%20%D1%84%D0%B0%D0%B9%D0%BB%D0%B0.png)

Порядок исполнения:
```
Клиент -> Получение метаданных таблицы -> Получение метаданных файла -> μ Ожидание • Проверить статус блокировки ->
    ( Ожидание
    | Заблокировать файл -> Записать файл -> Разблокировать Файл -> Клиент )
```
Порядок исполнения с возникновением ошибки:
```
Клиент -> Получение метаданных таблицы ->  μ Ожидание • Проверить статус блокировки ->
    ( Ожидание
    | Заблокировать файл -> СТОП
    | Заблокировать файл -> Получение метаданных файла -> Записать файл -> Разблокировать Файл -> Клиент )
```

Псевдо sql:
```sql
UPDATE `Таблица` SET c1=c1+1 WHERE id=1;
```

#### Изменения ссылок
Первый клиент пытается перевести сотрудника в новый отдел. Второй пытается удалить отдел с удалением всех сотрудников в нём состоявших, для поддержания целостности

1. Первый клиент получает метаданные таблицы Worker
2. Первый клиент читает сслыку на таблицу Job из таблицы worker, строка 1111

1. Первый клиент получает метаданные таблицы Job от базы метаданных таблиц
2. Первый клиент проверяет блокировку файла job/2111
3. Первый клиент блокирует файл job/2111 в базе таблице Job для записи
4. Первый клиент получает метаданные файла job/2111 от таблицы метаданных Job

5. Второй клиент получает метаданные таблицы Department
6. Второй клиент проверяет блокировку таблицы Department
7. Второй клиент блокирует строку department/4111
8. Второй клиент файл department/4111

9. Первый клиент проверяет блокировку файла department/4111 и переходит в ожидание, так как файл заблокирован вторым клиентом
10. Второй клиент удаляет строку department/4111

11. Второй клиент получает метаданные таблицы Job
12. Второй клиент получает сканирует таблицу Job для нахождения строк со ссылкой на department/4111
13. Второй клиент проверяет блокировку файла Job/2111. Файл заблокирован первым клиентом, поэтому второй клиент ожидает разблокировки

Оба клиента ожидают взаимной разблокировки требуемых ресурсов. Они заблокированны.

Схема БД до изменений:

![petri_db_change_links_schema](../media/petri_db-%D0%A1%D0%BC%D0%B5%D0%BD%D0%B0%20%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA%20%D1%81%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема БД до изменений для примера изменения ссылок

Схема работы:

![petri_db_link_change](../media/petri_db-%D0%A1%D0%BC%D0%B5%D0%BD%D0%B0%20%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA-1.png)


```
1.Клиент -> Получение метаданных таблицы worker -> Получение ссылки на таблицу job -> μ Ожидание • Проверить блокировку строки job/2111 ->
    ( Ожидание
    | Заблокировать строку job/2111 -> Получить метаданные файла job/2111 -> Получить метаданные файлов department -> μ Ожидание • Проверить блокировку файла(department/X) ->
        (Ожидание
        | Получить метаданные файла (department/X) -> Прочитать файл(department/X) -> Ожидание) -> Изменить строку job/2111 -> Разблокировать строку job/2111)) -> 1.Клиент
```
Псевдо sql:
```sql
UPDATE `Job`
SET fk_department = (select id from department where id = 4112)
WHERE fk_worker = (select id from worker where id = 1111);
```

```
2.Клиент -> Получение метаданных таблицы department -> μ Ожидание • Проверить блокировку строки department/4111 ->
    ( Ожидание
    | Заблокировать строку department/4111 -> Получить метаданные файла department/4111 -> Удалить файл department/4111 -> Получить метаданные таблицы job -> Получить список строк со ссылкой на department/4111 -> μ Ожидание • Проверить блокировку строки (job/X) ->
        ( Ожидание
        | Заблокировать строку (job/X) -> Получить метаданные файла (Job/X)) -> Изменить строку (Job/X)) -> μ • Разблокировать строку (job/X) -> разблокировать строку department/4111)) -> 2.Клиент
```
Псевдо sql:
```sql
DELETE FROM department WHERE id = 4111;
```


#### Удаление прав доступа к таблице
Первый клиент обновляет строки в таблице Department, потом в Employee. Второй клиент снимает с первого права на доступ к таблицам Department и Employee.
1. Первый клиент блокирует файл 4111 в таблице Department
2. Первый клиент изменяет файл 4111 в таблице Department
3. Второй клиент изменяет права доступа к таблице Employee и Department, запрещая первому клиенту доступ к ним
4. Первый клиент пытается заблокировать строку 2111 в таблице Employee, но не может, так как у него нет прав на доступ к этой таблице.

Первый клиент не может заблокировать строку 2111 в таблице Employee, в следствии этого он не может завершить транзакцию и остаётся в заблокированном состоянии.

Состояние БД:

![petri_db_access_revoke_schema](../media/petri_db-%D0%9E%D1%82%D0%B7%D1%8B%D0%B2%20%D0%BF%D1%80%D0%B0%D0%B2%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_access_revoke](../media/petri_db-%D0%9E%D1%82%D0%B7%D1%8B%D0%B2%20%D0%BF%D1%80%D0%B0%D0%B2.png)

```
1.Клиент -> Получение метаданных таблицы Department -> μ Ожидание • Проверить блокировку строки department/4111 ->
    ( Ожидание
    | Заблокировать файл department/4111 -> Получение метаданных файла department/4111 -> Изменить файл department/4111 -> Получение метаданных таблицы worker -> μ Ожидание • Проверить блокировку файла worker/2111 ->
        (Ожидание
        | Заблокировать файл worker/2111 -> получение метаданных файла worker/2111 -> Изменить строку worker/2111 -> Разблокировать строку worker/2111 -> Разблокировать строку department/4111)) -> 1.Клиент
```
Псевдо sql:
```sql
BEGIN TRANSACTION;

UPDATE `Department`
SET id = 4112
WHERE id = 4111;
```

```
2.Клиент -> Изменить права доступа клиента 1 -> 2.Клиент
```

### Между кластерами
#### Синхронизация изменений
Блокировка изменений кластера происходит только в пределах одного кластера.
1. Первый клиент блокирует файл 1111 в таблице table а первом кластере
2. Втором клиент блокирует файл 1111 в таблице table а втором кластере
3. Первый клиент изменяет файл 1111 в таблице table на первом кластере
4. Второй клиент изменяет файл 1111 в таблице table на втором кластере
5. Первый клиент получает список серверов, содержащих таблицу table
6. Второй клиент получает список серверов, содержащих таблицу table
7. Первый клиент пытается заблокировать файл 1111 в таблице table на втором кластере для репликации своих изменений, но не может этого сделать, так как строка заблокированна клиентом 2
8. Второй клиент пытается заблокировать файл 1111 в таблице table на первом кластере для репликации своих изменений, но не может этого сделать, так как строка заблокированна клиентом 1

Клиент 1 ожидает разблокировки файла на кластере 2, в то время как клиент 2 ожидает разблокировки файла на первом кластере. Оба клиента не могут продолжать работу.

Состояния БД:

![petri_db_replication_schema](../media/petri_db-%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_replication](../media/petri_db-%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F.png)

```
1.Клиент -> Получение метаданных таблицы 1.table -> μ Ожидание • Проверить блокировку строки 1.table/1111 ->
    ( Ожидание
    | Заблокировать файл 2.table/1111 -> Получение метаданных файла 1.table/1111 -> Изменить файл 1.table/1111 -> 1.Получение адресов серверов, содержащих таблицу table -> Получение метаданных таблицы 2.table -> μ Ожидание • Проверить блокировку файла 2.table/1111 ->
        (Ожидание
        | Заблокировать файл 2.table/1111 -> Получение метаданных файла 2.table/1111 -> Изменить строку 2.table/1111 -> Разблокировать строку 2.table/1111 -> Разблокировать строку 1.table/1111)) -> 1.Клиент
```
Псевдо sql:
```sql
UPDATE `table`
SET vale = 2
WHERE id = 1;
```

```
2.Клиент -> Получение метаданных таблицы 2.table -> μ Ожидание • Проверить блокировку строки 1.table/1111 ->
    ( Ожидание
    | Заблокировать файл 2.table/1111 -> Получение метаданных файла 2.table/1111 -> Изменить файл 2.table/1111 -> 2.Получение адресов серверов, содержащих таблицу table -> Получение метаданных таблицы 1.table -> μ Ожидание • Проверить блокировку файла 1.table/1111 ->
        (Ожидание
        | Заблокировать файл 1.table/1111 -> Получение метаданных файла 1.table/1111 -> Изменить строку 1.table/1111 -> Разблокировать строку 1.table/1111 -> Разблокировать строку 2.table/1111)) -> 2.Клиент
```
Псевдо sql:
```sql
UPDATE `table`
SET vale = 1000
WHERE id = 1;
```

## Возможные условия блокировок, сводящиеся к тем что описаны
1. Цикличная блокировка трёх клиентов с захватом каждого одного из трёх разделяемых ресуров - сводится к задаче с блокировкой двух клиентов с двумя ресурсами.
2. Блокировка в пересекающихся диапазонах - диапазоны реализованы только в формати блокировки поддерева индексов. Блокировка диапазона индексов описана в соответсвующем примере.
3. Блокировка через эскалацию блокировки от части строк до всей таблицы на двух клиентах - сводится к блокировке двух клиентов с двумя ресурсам. Если всего разделяемых ресурса два, то захват одного потом второго эквиваленте захвату одного потом всей таблицы
4. Блокировка в связи с медленной репликацией данных между серверами - сводится к блоировкой со взаимной репликацией, так как кейс описан событийно без привязки к длительноти процессов.
5. Взаимоисключающие операции над одним и тем же значении (инкрементирование и одновременное декрементироваие ресурса) - Задача сводится к задачам с n клиентов и n операций. Если есть хоть два разделяемых ресурса, то при захвате обоих разными клиентами процессы будут заблокированны. Если ресурс один, то он будет доступен процессам ожидающим его, после окончания работы процесса что его захватил.
6. Удаление таблицы одним клиентом перед захватом строки в ней другим - совпадает с примером изменения прав доступа, так как в обоих случаях у клиента полностью пропадает доступ к одному из требуемых разделяемых реурсов.