Описание системы
========================

Система представляет собой базу данных, использующая смешанные парадигмы реляционного хранилища и хранилища документов. Она выполняет требования ACID и поддерживает распределённое хранение.

## Примеры реализации
[fauna db](https://fauna.com/) [github](https://github.com/fauna)

[Calvin: Fast Distributed Transactions for Partitioned Database Systems](https://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf)

## Термины
Каталог - единица хранения данных. Представляет собой связку из папки на кластере в которой храняться файлы с данными. Таблицы метаданных каталога, описывающий структуру хранения и распределение данных для быстрого чтения и запись в мастер базе, описывающей расположение таблицы метаданных

Сервер метаданных каталога - выполняет функции балансировки партиций по серверам в кластере и хранения таблицы метаданных каталога.
Таблица метаданных каталога - описывает структуру хранения данных в катологе. Содержит ID записей, адреса серверов в кластере на которых содержится партиции, путь до файла и ссылка на внешние таблицы, если есть. Так же, в таблицу можно вынести список важных партиционных полей, для более быстрого поиска по ним.
| ID | server address | partition | file path | FK1 | FK2 | important partition |


База данных на master сервере - содержит ссылки на все каталоги, хранящиеся на кластере. Содержит имена каталогов, адрес таблицы метаданных каталога и схему каталога.
|  catalogue name | description table address | schema |

## Описание хранения
### Старая
![petridb_storage_schema](../media/qownnotes-media-ZImNDc.png)

На данной схеме представлена база данных сотрудников компании (employees). Даза данных состоит из двух таблиц: работников (workers) и отделов (departments).

Строка в таблице работника состоит из указания на файл с персональными данными работника в формате json (в данном примере файл ./storage/employees_db/workers/1111.json). И ссылки на строку в дочерней таблице job. Эта таблица имеет ссылку на файл с описанием профессиональных данных работника (./storage/employees_db/workers/job/2111.json), файл с описанием должности сотрудника в отделе, в котором так же содержится ссылка на сам отдел (./storage/employees_db/workers/department_work/3111.json) и отдельной ссылки на таблицу department, которая выполняет ту же функцию, что и ссылка в файле должности и служит в данном случае примерами реализации ссылок в бд.

Таблица с данными отделов имеет ссылку на файл с описанием отдела (./storage/employees_db/department/4111.json)

В качестве служеной информации в каждом из json файлов указан его id, названиие таблицы к которой относится данная запись и дата изменения.
### Новая
Система принимает на хранение докуенты в формате JSON. После загрузки они преобразуются в графовое представление и сохраняются в KV-хранилище. Документы загружаемые в систему хранятся в коллекциях. Ключ для списка всех созданных коллекций: *d:collections*.
## Порядок исполнения запросов
1. Клиент проводит созданного запроса и определяет список коллекций из которых ему потребуются данные.
2. Клиент обращается с этим списком к базе данных на master сервере для проверки существования этих коллекций и сборки адресов серверв с таблицами метаданных каталога и возможного получения схем.
3. Валидирует схемы с запросом
4. Обращается к каждой таблице метаданных каталога и получает адреса серверов и метаданные каталогов
5. Клиент обращается к серверам с каталогами и запускает на них локальные процессы по фильтрации и локальной агрегации данных, если возможно.
6. Клиент получает от всех серверов с нужными каталогами их загрузку по выбраным метрикам.
7. Клиент отправляет задачи локальным процессам для обмена данными в зависимости от загрузки
8. Клиент поддерживает heartbeat с запущенными на серверах процессами до получения результата


## Распределение и партиционирование
![petridb_partitioning_and_clustering](../media/qownnotes-media-EHyGHY.png)

Таблицы могут быть партиционированны в пределах одного кластера. При распределении таблицы ключи распределяются.

При разделении на кластера. Каждый кластер первого ранга получает полный состав таблиц, но может партиционировать их по своему. Кластеры второго ранга только реплицируют себе данные с кластеров первого ранга и могут только читать поучаемые данные, но не изменять их. Так же кластера второго ранга могут содержать не полный состав таблиц.

Кластера подразделяются на кластера первого и второго ранга. Синхронизация любых изменений происходит в пределах кластеров первого ранга, каждый из серверов первого ранга может предлагать изменения, которые синхронизируются при помощи протокола raft. После успешного согласования эти изменения записываются и отправляются кластерам второго ранга.

Принадлежность к первому рангу определяется по записям на сервереаутентификации кластеров. Только кластера аутентифицированные и с разрешением на запись могут предлагать изменения.

![petri_db-Синхронизация кластеров](../media/petri_db-%D0%A1%D0%B8%D0%BD%D1%85%D1%80%D0%BE%D0%BD%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F%20%D0%BA%D0%BB%D0%B0%D1%81%D1%82%D0%B5%D1%80%D0%BE%D0%B2.svg)


## Функции
### select
select_exact(collection_id, doc_id, field) - Выбирает значение конкретного поля
select_subtree(collection_id, doc_id, field) - выбирает значение поля и всех связанных полей в документе. Если указать поле root то вернёт весь документ.
select_document_where(collection_id, field, value) - ищет документ с указанным значением.
select_subtree_where(collection_id, field, value) - ищет часть документа начиная с подходящего значения.
### join
join_subtree(collection_id_1, key_1, collection_id_2, key_2) - Слединяет два дерева в одно. Позволяя работать с двумя json как с одним, подставляя вместо узла первого дерева все значения этого уровня дерева второго.
{
  "shipment_id": "SHP-777",
  "details": {
    "origin": {
      "warehouse_code": "WH-ALPHA",
      "city": "Berlin",
    },
    "priority": "high"
  }
}

{
  "site_info": {
    "metadata": {
      "code": "WH-ALPHA",
      "manager": "Schmidt",
      "stores": {"meat", "buns"},
    },
    "type": "cold_storage"
  },
  "current_stock": 1500
}
JOIN SUBTREE Shipments S AND Inventory I ON S.details.origin.warehouse_code = I.site_info.metadata.code as *warehouse*
{
  "shipment_id": "SHP-777",
  "details": {
    "origin": {
      "*warehouse_metadata*":  {
          "code": "WH-ALPHA",
          "manager": "Schmidt",
          "stores": {"meat", "buns"},
        },
      "city": "Berlin"
    },
    "priority": "high"
  }
}


join_documents(collection_id_1, key_1, collection_id_2, key_2) - Слединяет два дерева в одно. Позволяя работать с двумя json как с одним, подставляя вместо узла первого дерева узел второго, но сохраняет всю структуру второго дерева

{
  "shipment_id": "SHP-777",
  "details": {
    "origin": {
      "warehouse_code": "WH-ALPHA",
      "city": "Berlin"
    },
    "priority": "high"
  }
}

{
  "site_info": {
    "metadata": {
      "code": "WH-ALPHA",
      "manager": "Schmidt",
      "stores": {"meat", "buns"},
    },
    "type": "cold_storage"
  },
  "current_stock": 1500
}

JOIN Shipments S AND Inventory I ON S.details.origin.warehouse_code = I.site_info.metadata.code as *warehouse*

{
  "shipment_id": "SHP-777",
  "details": {
    "origin": {
      "*warehouse*": {
          "site_info": {
            "metadata": {
              "code": "WH-ALPHA",
              "manager": "Schmidt",
              "stores": {"meat", "buns"},
            },
            "type": "cold_storage"
          },
          "current_stock": 1500
        },
      "city": "Berlin"
    },
    "priority": "high"
  }
}
### insert
insert_subtree(collection_id, doc_id, field, value) - добавляет к указанному документу, к полю коллекции (array, map, collection) новое значение поддерева.
insert_document(collection_id, file) - загружает файл в коллекцию.
### update
update_value(collection_id, doc_id, field, value) - заменяет значение в документе на переданное функции. Может обновить поддерево.
### delete
delete_document(collection_id, doc_id) - Удаление документа.
delete_documents_where(collection_id, field, value) - удаление документов из коллекции удовлетворяющих условию.
### Управление коллекциями
create_collection(collection_id) - создание коллекции.
delete_collection(collection_id) - удаление коллекции и документов в ней.
