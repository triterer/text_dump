Разговоры с нейронкой
========================

Привет. Я пишу магистрскую диссертацию на тему "Разработка распределённой,  документно-реляционной базы данных и  методов её реализации". Поскольку это будет магистрская работа, то очень важна научная новизна проекта. Для достижения этой цели я планировал попробовать разработать алгоритм для выведения схемы из файлов и на основе неё проводить иерархическую блокировку записей. Для подтверждения работоспособности и отсуствия deadlock все алгоритмы в системе будут будут описыватся при помощи нотации CSP Хоара и потом смоделированны при помощи сетей Петри.  Хранимые документы разбиваются на отдельные поля  помощи теории графов и  хранятся как KV значения в RocksDB, где ключ это путь, а значение зависит от типа узла. Есть три варианта:
- Скаляр: Само значение.
- Объект: Список ключей (указателей на дочерние узлы). Это позволяет "ходить" по графу.
- Массив: Список индексов (виртуальных указателей).

Название коллекции документов, название документов отделяются двоеточием части пути разделяются точкой. Например следующий JSON:
```JSON
{
    "scalar": "some value",
    "array": ["first", "another"],
    "object": {
        "internal key": 1
    }
}
```
Преобразуется в следующие записи:
| key | value |
| --- | --- |
| d:collection_1:document_1:scalar | "some value"|
| d:collection_1:document_1:array | [1, 2] |
| d:collection_1:document_1:array[1] | "first"|
| d:collection_1:document_1:array[2] | "another"|
| d:collection_1:document_1:object | ["internal key"] |
| d:collection_1:document_1:object.internal key | 1 |

Поскольку для эффективных блокировок потребуется разработать систему которая будет выводить схему для коллекции при загрузке документов и обновлять её. Система Schema Registry управляет глобальной эволюционирующей схемой коллекции. Схема персистентно хранится на диске и полностью загружается в оперативную память модуля Distributed Lock Manager (DLM) при старте. Для эффективного поиска и хранения блокировок дерево путей формируется в виде Prefix tree.

При поступлении нового документа Schema Registry строит его локальный граф путей и накладывает его на глобальную схему. Если обнаруживаются новые пути, глобальная схема обновляется расширяется), и обновленная версия синхронизируется с памятью DLM и диском. Так же она будет выделять следующие типы узлов: scalar (числа, строковые и булевы значения), object и array. Алгоритм обхода следующий:
- Если встречается Scalar: формируется терминальный узел.
- Если встречается Object: в узле сохраняется список ключей, затем для каждого ключа создается ветка и алгоритм вызывается рекурсивно.
- Если встречается Array: в корневом элементе записывается максимально возможное число элементов массива, а затем элементы массива индексируются, создавая виртуальные узлы типа [i].

При объединении схем могут возникать структурные конфликты. Они происходят, если один и тот же путь в существующей схеме помечен как Scalar, а в новом документе является Object, или наоборот.

Для распределённсти мы запускаем локальный Schema Registry на каждом узле. Они синхронизируются при помощи протокола Raft. Если изменеия структуры на лидере, то он распространяет их на все узлы. А если на другом, то он сначала согласует изменения с лидером и последний либо распространяет изменения либо нет.

Кроме схемы мы храним связи серверов в кластере и коллекций, которые на этих серверах хранятся. Если Одна коллекция не влезает на сервер, то через consistent hashing из doc_id определяем, на какой сервер попдёт документ целиком.

Дерево блокировок формируется динамически для каждого документа. По мере продвижения мы проверяем совместимость имеющихся блокировок на узле с той блокировкой, которую хотим поставить. Если узла нет, то формируем его и ставим блокировку. 

Как мы блокируем узлы в одном файле?
Мы добавлям замок постепенно, проставляя интенционные блокировки на этапы пути и конкретные блокировки на узлы с которых начинаем собирать дерево для чтения или записи.

Как мы блокируем узлы в нескольких файлах?
Если есть список файлов для блокировки, то упорядочиваем все бокирвки в алфавитном порядке, а потом начинаем из исполнять.  
Если списка нет и у нас есть только условие для выбора нужных документов, то сначала мы производим блокировку чтения по атрибуту, по которому будет проходить фильтрация. Читаем данные этого атрибута в документах и собираем список документов. Потом проводим блокировку этих документов на нужном уровне и снимаем блокировки, которые ставили для чтения атрибутов для фильтрации. После этого рабоаем с выбранными документами.

Как мы перносим структуру из Schema Registry в DLM?
При получении запроса на блокировкуНАличие поля верифицируется с Schema Registry перед блокировками, так что если запрос блокировки дошёл до DLM, то сверять ничего уже не нужно.

Как мы действуем при расширении схемы?
Вроде ничего делать не надо. При добавлении узлов, мы просто их не читаем, так как не знали о существовании. А при добавлении новых типов данных мы сможем их прочесть.

Как синхронизируются замки в DLM?
Никак. Каждый инстанс управляет блокировками только на своём сервере.

Как блокируемся при транзитивных запросах, например join?
Блокировки чтения на каждый документ в обоих коллекциях. Потом чтение. Выборка подходящих под условие докуметов и повышение блокировк при необходимости.

Как хранить список документов в коллекции и как его обновлять?
Прям в KV хранилище по ключу d:collection:Docs = [Doc1, Doc2]. При обновлении надо ставить блокировки, благо для этого тоже можно построить дерево. В целом эта структура будет подвергнута постоянному насилию.

По архитектуре моя система будет состоять из:
- Data Nodes (Rust + RocksDB): Хранят JSON файлы преобразованные к представлению KV (Путь, значение).
- Distributed Lock Manager (внутри тех же узлов): Управляет иерархическими блокировками для своих данных.
- Schema Registry: Маленькая отказоустойчивая прослойка для хранения структур файлов в коллекциях.

---

Мне не надо говорить что у меня сильный базис для доказания научности. Основной упор делается на DLM и верификацию избегания блокировок. Механизм динамического выведения и эволюции схемы не является важным элементом этой работы.

---

Сейчас я готовлюсь к написанию доклада на конференции. Составь план этого доклада на тему формирования блокировок в этой СУБД.

---

### Обновленное полное описание (Собранное воедино)
Если ты хочешь использовать этот текст как "питч" проекта или введение, вот исправленная и более строгая версия:
**Тема:** Разработка распределённой документно-реляционной базы данных с иерархической блокировкой на основе выводимых схем.
**Принцип хранения:**
Документы (JSON) декомпозируются на атомарные KV-записи в RocksDB, где ключ — это путь.
* **Scalar Node:** Хранит значение поля.
* **Array Node:** Хранит список *стабильных индексов* элементов (виртуальные ID) для сохранения целостности путей при мутациях.
* **Object Node:** Хранит список ключей-полей.
**Архитектура и Алгоритмы:**
1. **Schema Registry (Управление структурой):** Поддерживает глобальную, эволюционирующую схему данных. При записи документа его структура накладывается на текущую глобальную схему.
    * Узлы классифицируются как **Leaf** (значение) или **Branch** (контейнер).
    * **Union Nodes:** Если путь одновременно является Leaf и Branch (в разных документах), создается гибридный узел Union для разрешения структурной неоднозначности.
2. **Distributed Lock Manager (DLM):**
    * Держит актуальную схему в памяти в виде **Radix Tree**.
    * Использует эту схему для **иерархических блокировок** (Intention Locks на ветках, Exclusive/Shared на листьях).
    * Это позволяет блокировать не весь документ, а только изменяемые поддеревья, избегая Deadlocks (доказывается через CSP и сети Петри).
3. **Data Nodes (Rust + RocksDB):** Физическое хранение и исполнение логики.


