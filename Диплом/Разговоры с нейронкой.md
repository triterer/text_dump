Разговоры с нейронкой
========================

Привет. Я пишу магистрскую диссертацию на тему "Разработка распределённой,  документно-реляционной базы данных и  методов её реализации". Поскольку это будет магистрская работа, то очень важна научная новизна проекта. Для достижения этой цели я планировал попробовать разработать алгоритм для выведения схемы из файлов и на основе неё проводить иерархическую блокировку записей. Для подтверждения работоспособности и отсуствия deadlock все алгоритмы в системе будут будут описыватся при помощи нотации CSP Хоара и потом смоделированны при помощи сетей Петри.  Хранимые документы разбиваются на отдельные поля  помощи теории графов и  хранятся как KV значения в RocksDB, где ключ это путь, а значение зависит от типа узла. Есть три варианта:
- Скаляр: Само значение.
- Объект: Список ключей (указателей на дочерние узлы). Это позволяет "ходить" по графу.
- Массив: Список индексов (виртуальных указателей).

Название коллекции документов, название документов отделяются двоеточием части пути разделяются точкой. Например следующий JSON:  
```JSON
{
    "scalar": "some value",
    "array": ["first", "another"],
    "object": {
        "internal key": 1
    }
}
```
Преобразуется в следующие записи:
| key | value |
| --- | --- |
| d:collection_1:document_1:scalar | "some value"|
| d:collection_1:document_1:array | [1, 2] |
| d:collection_1:document_1:array[1] | "first"|
| d:collection_1:document_1:array[2] | "another"|
| d:collection_1:document_1:object | ["internal key"] |
| d:collection_1:document_1:object.internal key | 1 |

Поскольку для эффективных блокировок потребуется разработать систему которая будет выводить схему для коллекции при загрузке документов и обновлять её. Система Schema Registry управляет глобальной эволюционирующей схемой коллекции. Схема персистентно хранится на диске и полностью загружается в оперативную память модуля Distributed Lock Manager (DLM) при старте.

При поступлении нового документа Schema Registry строит его локальный граф путей и накладывает его на глобальную схему. Если обнаруживаются новые пути, глобальная схема обновляется (расширяется), и обновленная версия синхронизируется с памятью DLM и диском. Так же она будет выделять следующие типы узлов: leaf и branch. Алгоритм обхода следующий:
- Если встречается Scalar (число, строка): формируется терминальный узел (лист).
- Если встречается Object: для каждого ключа создается ветка и алгоритм вызывается рекурсивно.
- Если встречается Array: элементы массива индексируются, создавая виртуальные узлы типа [i].

При объединении схем могут возникать структурные конфликты. Они происходят, если один и тот же путь в существующей схеме помечен как Leaf (терминальное значение), а в новом документе является Branch (промежуточным узлом для вложенных данных), или наоборот.

В таких случаях в графе схемы создается специальный узел Union Type. Он позволяет DLM корректно обрабатывать блокировки, понимая, что по данному пути может находиться как конкретное значение, так и поддерево на основе которых можно будет потом проводить блокировки на необходимом уровне. После этого схема будет читаться следующим модулем Distributed Lock Manager. Он на основе описания схемы должен хранить в себе структуру коллекции в виде Radix tree. Он должен принимать запросы на доступ к узлам, управлять блокировками узлов таким образом что бы избегать взаимных блокировок.

По архитектуре моя система будет состоять из:
- Data Nodes (Rust + RocksDB): Хранят JSON файлы преобразованные к представлению KV (Путь, значение). 
- Distributed Lock Manager (внутри тех же узлов): Управляет иерархическими блокировками для своих данных.
- Schema Registry: Маленькая отказоустойчивая прослойка для хранения структур файлов в коллекциях.

---

Сейчас я занят второй главой диплома. Это глава, связанная с исследованием. Здесь может быть математическое исследование, инновационное. Если она относится к прикладной, это нужно брать какие-то модели, которые решают нашу задачу, сравнивать их на эталонном датасете, получать результат и лучшую модель брать за baseline, для дальнейшей ей доработки.

---

Сейчас давай проработаем теоретическую основу Distrbuted Lock Manager. Надо продумать как будет преобразовыватся плоская структура из Schema Registry в Radix tree в DLM. Как на это будут влиять эволюция схемы. Надо составить список возможных блокировок и их взаимодействия с учётом Union type узлов, к ним должны применятся стратегии shadow leaf, когда блокировка и доступ будут зависеть от того к какому типу узла происходит обращение.  Под всё это необходимо подготовить список исследований для цитирования из фундаментальных и свежих (не старше 2023). Можешь использвать несколько сообщений

---

### Обновленное полное описание (Собранное воедино)
Если ты хочешь использовать этот текст как "питч" проекта или введение, вот исправленная и более строгая версия:
**Тема:** Разработка распределённой документно-реляционной базы данных с иерархической блокировкой на основе выводимых схем.
**Принцип хранения:**
Документы (JSON) декомпозируются на атомарные KV-записи в RocksDB, где ключ — это путь.
* **Scalar Node:** Хранит значение поля.
* **Array Node:** Хранит список *стабильных индексов* элементов (виртуальные ID) для сохранения целостности путей при мутациях.
* **Object Node:** Хранит список ключей-полей.
**Архитектура и Алгоритмы:**
1. **Schema Registry (Управление структурой):** Поддерживает глобальную, эволюционирующую схему данных. При записи документа его структура накладывается на текущую глобальную схему.
    * Узлы классифицируются как **Leaf** (значение) или **Branch** (контейнер).
    * **Union Nodes:** Если путь одновременно является Leaf и Branch (в разных документах), создается гибридный узел Union для разрешения структурной неоднозначности.
2. **Distributed Lock Manager (DLM):**
    * Держит актуальную схему в памяти в виде **Radix Tree**.
    * Использует эту схему для **иерархических блокировок** (Intention Locks на ветках, Exclusive/Shared на листьях).
    * Это позволяет блокировать не весь документ, а только изменяемые поддеревья, избегая Deadlocks (доказывается через CSP и сети Петри).
3. **Data Nodes (Rust + RocksDB):** Физическое хранение и исполнение логики.
