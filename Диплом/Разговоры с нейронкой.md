Разговоры с нейронкой
========================

Привет. Я пишу магистрскую диссертацию на тему "Разработка распределённой,  документно-реляционной базы данных и  методов её реализации". Поскольку это будет магистрская работа, то очень важна научная новизна проекта. Для достижения этой цели я планировал попробовать разработать алгоритм для выведения схемы из файлов и на основе неё проводить иерархическую блокировку записей. Для подтверждения работоспособности и отсуствия deadlock все алгоритмы в системе будут будут описыватся при помощи нотации CSP Хоара и потом смоделированны при помощи сетей Петри.  Хранимые документы разбиваются на отдельные поля  помощи теории графов и  хранятся как KV значения в RocksDB, где ключ это путь, а значение зависит от типа узла. Есть три варианта:
- Скаляр: Само значение.
- Объект: Список ключей (указателей на дочерние узлы). Это позволяет "ходить" по графу.
- Массив: Список индексов (виртуальных указателей).

Название коллекции документов, название документов отделяются двоеточием части пути разделяются точкой. Например следующий JSON:
```JSON
{
    "scalar": "some value",
    "array": ["first", "another"],
    "object": {
        "internal key": 1
    }
}
```
Преобразуется в следующие записи:
| key | value |
| --- | --- |
| d:collection_1:document_1:scalar | "some value"|
| d:collection_1:document_1:array | [1, 2] |
| d:collection_1:document_1:array[1] | "first"|
| d:collection_1:document_1:array[2] | "another"|
| d:collection_1:document_1:object | ["internal key"] |
| d:collection_1:document_1:object.internal key | 1 |

Поскольку для эффективных блокировок потребуется разработать систему которая будет выводить схему для коллекции при загрузке документов и обновлять её. Система Schema Registry управляет глобальной эволюционирующей схемой коллекции. Схема персистентно хранится на диске и полностью загружается в оперативную память модуля Distributed Lock Manager (DLM) при старте. Для эффективного поиска и хранения блокировок дерево путей формируется в виде Radix tree.

При поступлении нового документа Schema Registry строит его локальный граф путей и накладывает его на глобальную схему. Если обнаруживаются новые пути, глобальная схема обновляется (расширяется), и обновленная версия синхронизируется с памятью DLM и диском. Так же она будет выделять следующие типы узлов: leaf и branch. Алгоритм обхода следующий:
- Если встречается Scalar (число, строка): формируется терминальный узел (лист).
- Если встречается Object: для каждого ключа создается ветка и алгоритм вызывается рекурсивно.
- Если встречается Array: элементы массива индексируются, создавая виртуальные узлы типа [i].

При объединении схем могут возникать структурные конфликты. Они происходят, если один и тот же путь в существующей схеме помечен как Leaf (терминальное значение), а в новом документе является Branch (промежуточным узлом для вложенных данных), или наоборот.

В таких случаях в графе схемы создается специальный узел Union Type. Он позволяет DLM корректно обрабатывать блокировки, понимая, что по данному пути может находиться как конкретное значение, так и поддерево на основе которых можно будет потом проводить блокировки на необходимом уровне. После этого схема будет читаться следующим модулем Distributed Lock Manager. Он на основе описания схемы должен хранить в себе структуру коллекции в виде Radix tree. Он должен принимать запросы на доступ к узлам, управлять блокировками узлов таким образом что бы избегать взаимных блокировок.

По архитектуре моя система будет состоять из:
- Data Nodes (Rust + RocksDB): Хранят JSON файлы преобразованные к представлению KV (Путь, значение).
- Distributed Lock Manager (внутри тех же узлов): Управляет иерархическими блокировками для своих данных.
- Schema Registry: Маленькая отказоустойчивая прослойка для хранения структур файлов в коллекциях.

---

Сейчас я занят первой главой диплома. Это глава связанная с  анализом предметной области. Задача провести литобзор, то есть посмотреть в данной тематике, какие применяются методы, алгоритмы, подходы, для того, чтобы проанализировать, что на данный момент уже есть и какая есть проблематика. Исходя из этого, переходят к второй главе.

На данный момент я уже написал её. Давай теперь вместе отсмотрим и доработаем её. Я буду давать тебе фрагменты текста, а ты будешь предлагать варианты его улучшения.

---

### Обновленное полное описание (Собранное воедино)
Если ты хочешь использовать этот текст как "питч" проекта или введение, вот исправленная и более строгая версия:
**Тема:** Разработка распределённой документно-реляционной базы данных с иерархической блокировкой на основе выводимых схем.
**Принцип хранения:**
Документы (JSON) декомпозируются на атомарные KV-записи в RocksDB, где ключ — это путь.
* **Scalar Node:** Хранит значение поля.
* **Array Node:** Хранит список *стабильных индексов* элементов (виртуальные ID) для сохранения целостности путей при мутациях.
* **Object Node:** Хранит список ключей-полей.
**Архитектура и Алгоритмы:**
1. **Schema Registry (Управление структурой):** Поддерживает глобальную, эволюционирующую схему данных. При записи документа его структура накладывается на текущую глобальную схему.
    * Узлы классифицируются как **Leaf** (значение) или **Branch** (контейнер).
    * **Union Nodes:** Если путь одновременно является Leaf и Branch (в разных документах), создается гибридный узел Union для разрешения структурной неоднозначности.
2. **Distributed Lock Manager (DLM):**
    * Держит актуальную схему в памяти в виде **Radix Tree**.
    * Использует эту схему для **иерархических блокировок** (Intention Locks на ветках, Exclusive/Shared на листьях).
    * Это позволяет блокировать не весь документ, а только изменяемые поддеревья, избегая Deadlocks (доказывается через CSP и сети Петри).
3. **Data Nodes (Rust + RocksDB):** Физическое хранение и исполнение логики.

---

На основе наших обсуждений я подготовил структурированное описание системы. Этот текст можно использовать как основу для введения или технического резюме в твоем дипломе.

---

## Техническое описание гибридной документно-реляционной СУБД

Проектируемая система представляет собой высокопроизводительную распределенную базу данных, сочетающую гибкость документов (JSON) со строгими гарантиями целостности и параллелизма реляционных систем. Основной фокус системы направлен на решение проблемы «ложных конфликтов» при конкурентном доступе к глубоко вложенным структурам.

### 1. Архитектурный стек технологий

Система построена на принципах многоуровневого хранения и управления:

* **Язык реализации:** **Rust**. Выбран для обеспечения безопасности памяти без использования сборщика мусора (GC) и достижения производительности уровня C++.
* **Уровень хранения (Persistence):** **RocksDB**. Используется как низкоуровневое хранилище на базе LSM-деревьев (Log-Structured Merge-tree). Это обеспечивает высокую скорость записи и эффективное хранение разреженных данных.
* **Модель данных:** **JSON-ориентированная**. Документы представляются в виде ориентированных ациклических графов (DAG), где каждый путь является уникальным ресурсом.
* **Distributed Lock Manager (DLM):** Собственная реализация в оперативной памяти на базе **Radix Tree (префиксного дерева)**.

---

### 2. Ключевые функции и механизмы

Система реализует ряд инновационных механизмов для управления параллелизмом:

#### А. Динамический инференс схемы (Schema Inference)

В отличие от классических СУБД, система не требует предописания таблиц. При поступлении документа алгоритм **on-the-fly** выполняет рекурсивный обход и строит «карту путей». Это позволяет Lock Manager мгновенно определять иерархию ресурсов для наложения блокировок.

#### Б. Мелкогранулярное иерархическое блокирование (MGL)

Реализован протокол иерархических блокировок, который позволяет транзакциям работать с разными частями одного документа одновременно.

* **Интенционные блокировки (IS, IX):** Устанавливаются на родительские узлы (например, корень документа), сигнализируя о намерении работать на глубине.
* **Целевые блокировки (S, X):** Устанавливаются на конкретные поля (пути), минимизируя область блокирования.

#### В. Управление полиморфными коллизиями

Система корректно обрабатывает ситуации, когда одно и то же поле в разных документах имеет разные типы данных (скаляр vs объект). В таких случаях узел в Radix Tree переходит в состояние **Hybrid Node**, обеспечивая изоляцию транзакций по наиболее строгому правилу совместимости.

---

### 3. Формально-логический базис

Научная новизна и корректность системы подтверждаются использованием математических моделей:

* **CSP (Communicating Sequential Processes):** Модель Хоара используется для описания взаимодействия транзакций как независимых процессов, исключая неопределенность в поведении системы.
* **Сети Петри:** Применяются для верификации алгоритмов блокировки на отсутствие тупиковых ситуаций (Deadlocks) и подтверждения живости (Liveness) системы.
* **Теория решеток типов (Type Lattices):** Обосновывает процесс слияния схем и обработки коллизий типов при инференсе.

---

### 4. Сравнительные преимущества (относительно Baseline)

| Характеристика | Традиционные NoSQL (Baseline) | Разрабатываемая СУБД |
| --- | --- | --- |
| **Уровень блокировки** | Весь документ (Root) | Конкретный путь (Path) |
| **Параллелизм** | Низкий (очередь к документу) | Высокий (параллельный доступ к полям) |
| **Схема данных** | Отсутствует / На чтении | Динамическая в Lock Manager |
| **Конфликты** | Ложные конфликты на корне | Только реальные конфликты по путям |

---

### Твой следующий шаг:

Это описание охватывает все «умные» части твоей системы. Чтобы двигаться дальше по второй главе, я предлагаю:

1. **Начать визуализацию:** Нарисовать сеть Петри для твоего алгоритма (как транзакция запрашивает блокировку и засыпает/просыпается).
2. **Описать алгоритм слияния (Merge) схем:** Как именно  обновляется при добавлении нового документа.

**Хочешь, мы попробуем нарисовать (описать текстом для графики) структуру твоей сети Петри, чтобы окончательно «закрыть» вопрос с научной верификацией?**
