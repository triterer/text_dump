Эволюция схемы и Union узлы
========================

При добавлении в новых документов узлов к схеме, мы просто присоединяем новые узлы к схеме и записываем новые пути в KV хранилище. При этом с блокировками ничего делать не надо.

Есть три типа узлов :
- scalar - Это обычные числа. Можно создавать последний сегмент ветки и хранить в нём число документов с этим полем или тип этого поля.
- Object - не упорядоченный список ключ-значения
- array - упорядоченный список объектов

Преобразовываем следующим образом. Вот четыре json документа. 
```JSON
{
  a: "some value"
}
```
```JSON
{
  a: [
    b: "another value"
  ]
}
```
```JSON
{
  a: {
    b: "another value"
  }
}
```
```JSON
{
  a: [{
    b: "another value"
  }]
}
```

Полное представление:
![my_db_v2-Schema Registry](../media/my_db_v2-Schema%20Registry.png)

Сокращённое представление:
![my_db_v2-Schema Registry](../media/my_db_v2-Schema%20Registry-1.png)


Есть ли у нас варианты автоматически удалять ветви?
~~Да, мы можем в Schema Registry хранить количество таких атрибутов в Schema Resistry. Надо будет только сделать блокировку на время декримента и инкремента. Если Schema Registry будет распределённым, то это будет болью в заднице синхрнизировать изменения в этом числе.~~

Нет. Никак. Слишком сложно и долго. Для этого надо распределённо подсчитывать количество элементов по даннму пути на этой ноде, а при  добавлении и удалении менять это число. Что значит что нужны будут блокировки на уровне самого Schema Registry. Нам пока хватит Scope creep

Есть ли у нас вариант автоматически откатывать union узлы в оставшееся представление?