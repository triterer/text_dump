Глава 1. Введение
========================

## 1 Актуальность темы
В современном мире существует несколько традиционных подхода к построению базы данных, включая графовый, ключ-значение, векторный и другие. Но для целей хранения бизнес данных обычно применяются реляционные базы данных или документные. У каждого из подходов есть свои преимущества и недостатки с которыми сталкиваются пользователи баз данных с такими подходами. Рассмотрим их подробнее.

В реляционных базах данных предполагается жёсткая структуризация данных, что позволяет поддерживать данные в консистентном состоянии. Такой подход удобен с точки зрения потребления данных, но может вызывать проблемы в связи с необходимостью сложной обработки перед загрузкой в базу данных. Но сложнее чем эта операция наступает при необходимости изменения структуры хранения данных, так как для этого требуются отдельные процедуры миграции данных, создаваемые под конкретный случай. Другой выделяемой стороной реляционных БД часто выделяют транзакционность и изоляцию. Так как очень важно чтобы при изменении данных все изменения происходили целиком или не происходили вовсе. Данное свойство порождает проблему связанную с блокировками, возникающими в процессе работы, которые могут сильно сказываться на производительности базы данных. И ещё одной проблемой реляционных баз данных можно назвать проблему с расширением, так как обычно такие системы предполагают только вертикальное расширение вычислительных ресурсов и ресурсов хранения.

В противовес этому подходу выступает документные базы данных. Они позволяют хранить слабо структурированные данные и обрабатывать их по разному в зависимости от текущей задачи. Этот подходи решает проблему, которая возникает при необходимости переосмысления подхода к обработке данных при их потреблении. Однако это повышает сложность логики работы с данными при потреблении и приводит к увеличению времени работы. Другим важным аспектом документных баз данных это их готовность к горизонтальному расширению по мере роста потребности в увеличении объёма хранения. Так же к преимуществам документных базах данных можно потенциально записать отсутствие или низкое число блокировок, но недостатком этого подхода является отсутствие транзакционности и как следствие постоянной консистентности данных.

В данной работе для решения проблем, описанных выше будет применятся подход построения документно-реляционной базы данных. Это позволит хранить данные в виде файлов и применять к ним структуру по мере изменения понимания их значения без проведения глобальной миграции. При этом возможно будет реализовать выполнение требований ACID при проведении транзакций в базе данных. Но выполнение данных требований может приводит к слишком длительным блокировкам и длительному времени выполнения транзакций. Но хуже того, ошибки при выполнении данных требований могут приводить к взаимозаблокированному состоянию транзакций. И поскольку разрабатываемая система будет выполнять требования распределённости, то выполнение всех этих требований усложняется необходимостью консистентности во всех репликах данных.

Для решения проблемы взаимных блокировок в распределённой системе хранения в данной работе будут применяться средства математического моделирования и анализа сложных систем. Данный подход позволит эффективно проектировать систему, что бы в дальнейшем предотвращать возникновение тупиков.
## 2 Разработанность темы
Возникновение взаимных блокировок в системах с взаимодействующими последовательными процессами было и остаётся актуальной темой исследований. Такие состояния, методы их предупреждения и разрешения уже возникших тупиков исследуются применимо к абстрактным моделям параллельных систем в работах С. Тенможи, Р. Т. Субаракша, Ф. Адоббати, Л. Микульски. Так и в частности применимо к базам данных в работах М. Мину, У. Шанкера, С. Манаркхи, А. Ядхав, Т. Парае и А. Гейт.  В этих исследованиях представлены различные методы обнаружения таких ситуаций, от построения деревьев состояний до применения специализированных алгоритмов искусственного интеллекта.  В данной работе будет применяться подход проектирования и математического моделирования систем базирующиеся на работах Дж. Питерсона, Ч. Хоара и В. Котова. Актуальность применения данных подходов подтверждается исследованиями о применениях этих методов в работах Ч. Кианлонга, Х. Чи, А. Эль-шербини.

Исходя из перечисленных выше исследований в разработке систем с взаимодействующими системами и фундаментальных исследований о проблемах построения баз данных и распределённых систем, представленных в работах П. Беренштейна, С. Цери, К. Чанди, можно выделить следующие перспективные направления исследований:
    • предикативное избежание блокировок — разработка системы, которая потенциально не будет впадать в состояние взаимной блокировки позволит экономить время на поиске и устранении подобных ситуаций.
    • глобальная синхронизация изменений — разработка методов достижения глобального, транзакционного консенсуса позволит поддерживать глобальную синхронизацию данных в системе
    • сокращение количества циклов синхронизации — важным элементом синхронизации является согласованность изменений на всех узлах сети, что может требовать большого количества запросов на подтверждение изменений и их согласований. Сокращение раундов согласований позволит ускорить работу системы.
## 3 Цель работы
Целью данной диссертационной работы является анализ и выявление тупиковых состояний в процессе работы документно-реляционной базы данных. С последующим изменением алгоритмов, приводящим к появлению тупиковых состояний в системе, при помощи методов математического анализа.
## 4 Задачи
Для достижения поставленной цели, потребуется выполнить следующие задачи:
1. Описать принцип работы системы и возможные места возникновения взаимных блокировок в системе.
2. Формализовать алгоритмы работы системы в которых могут возникать блокировки при помощи блок-схем.
3. Построить математические модели последовательных взаимодействующих процессов при помощи сетей петри.
4. Провести исследование построенных математических моделей с целью нахождения возможности достижения взаимных блокировок компонентами системы.
5. Применяя методы математического моделирования и теории графов, изменить построенную математическую модель с целью устранения возможных блокировок системы.
## 5 Объект и предмет исследования
Объектом исследования в данной работе выступают методы реализации документно-реляционной базы данных.

Предметом исследования является разработка методов чтения, записи, изменения и репликации данных. Важным свойством этих операций является требование избежания тупикового состояния системы.
## 6 Анализ предметной области
Подход создания документно-реляционных баз данных является редким подходом к реализации базы данных. Среди примеров таких баз данных можно назвать два проекта hadoop и faunadb.
Стек hadoop, состоящий из файлового хранилища hdfs, способного хранить в иерархической файловой структуре файлы любых форматов. А СУБД позволяет работать с файлами хранящимися в hdfs при помощи SQL подобного языка HIVEQL. Данный проект способен способен обрабатывать большие объёмы данных и работать с разными структурами файлов, используя при этом простой синтаксис SQL. Однако в этом стеке не предусмотрена транзакционность и изолированность операций. Так например в ситуации когда один процесс производит чтение определённого файла, а другой начнёт его изменять, то первый процесс мгновенно завершится с ошибкой. А автоматическое поддержание консистентности в данном виде базы данных невозможно, так как внешние ключи могут присутствовать только в формате обозначенных колонок. База данных не производит автоматического поддержания консистентности.
Проект faunadb в свою очередь представляет собой полноценную документно-реляционную базу данных, которая выполняет требования ACID и имеет собственный язык для работы с данными и метаданными таблиц, который называется FQL. В данной системе данные хранятся в формате файлов json, а структура таблиц создаётся отдельно в формате реляционной базы метаданных. Транзакционность в работе данной системы достигается путём применения протокола Кельвина. Для него требуется упорядочивать выполнение всех транзакций в на центральном сервере и параллельное исполнение групп транзакций на серверах данных. Однако в данной системе применяются не системные часы отдельных серверов для упорядочивания транзакций, а порядковый номер транзакций . При данном подходе не всегда можно надёжно предполагать результаты, которые будут получены в результате исполнения транзакции.
Для решения обозначенных выше проблем в данной работе будут проанализированы возможные ситуации взаимных блокировок параллельных процессов и с применением методов моделирования сетями Петри.
## 7 Список примеров возможных взаимных блокировок
На предварительном этапе исследования были выделены следующие потенциальные сценарии при которых может возникнуть взаимная блокировка в системе.
### 7.1 Ошибка на клиенте во время записи
Ошибка на клиенте во время редактирования записи.
Алгоритм:
    1) Клиент получает метаданные таблицы от базы метаданных таблиц
    2) Клиент помечает в базе данных таблицы файл как заблокированный для изменений
    3) Клиент получает метаданные файла который собирается изменить от базы данных данной таблицы
    4) Клиент изменяет файл
    5) Ошибка на клиенте не даёт ему возможности завершить процесс
Файл остаётся в заблокированном состоянии. Другие клиенты, которые будут пытаться получить доступ к файлу будут ждать его разблокировки, которая никогда не наступит.
### 7.2 Взаимоисключающие изменения двух клиентов
Первый клиент должен добавить имя работника к описанию его должности. Второй должен добавить каждому работнику название отдела в личные данные.
Структура базы данных до изменений для этого примера представлена на Рисунке 1.


Алгоритм:
    6) Первый клиент получает метаданные таблицы Worker от базы метаданных таблиц
    7) Первый клиент проверяет блокировку файла worker/1111
    8) Первый клиент блокирует файл worker/1111 в базе таблице Worker
    9) Первый клиент получает метаданные файла worker/1111 от таблицы метаданных worker
    10) Первый клиент изменяет файл worker/1111
    11) Второй клиент получает метаданные таблицы Job от базы метаданных таблиц
    12) Второй клиент проверяет блокировку файла job/2111
    13) Второй клиент блокирует файл job/2111 в базе таблице Job
    14) Второй клиент получает метаданные файла job/2111 от таблицы метаданных job
    15) Второй клиент изменяет файл job/2111
    16) Первый клиент получает метаданные таблицы Job от базы метаданных таблиц
    17) Первый клиент проверяет блокировку файла job/2111, файл заблокирован вторым клиентом. Первый клиент ждёт разблокировки файла
    18) Второй клиент получает метаданные таблицы Worker от базы метаданных таблиц
    19) Второй клиент проверяет блокировку файла worker/1111, файл заблокирован первым клиентом. Второй клиент ждёт разблокировки файла
Оба клиента захватили часть данных и ожидают изменения друг у друга. Они заблокированы.
### 7.3 Изменения ссылок
Первый клиент пытается перевести сотрудника в новый отдел. Второй пытается удалить отдел с удалением всех сотрудников в нём состоявших, для поддержания целостности.
Структура базы данных до изменений для примера изменения ссылок представлена на Рисунке 2.

Алгоритм:
    20) Первый клиент получает метаданные таблицы Worker
    21) Первый клиент читает ссылку на таблицу Job из таблицы worker, строка 1111
    22) Первый клиент получает метаданные таблицы Job от базы метаданных таблиц
    23) Первый клиент проверяет блокировку файла job/2111
    24) Первый клиент блокирует файл job/2111 в базе таблице Job для записи
    25) Первый клиент получает метаданные файла job/2111 от таблицы метаданных Job
    26) Второй клиент получает метаданные таблицы Department
    27) Второй клиент проверяет блокировку таблицы Department
    28) Второй клиент блокирует строку department/4111
    29) Второй клиент файл department/4111
    30) Первый клиент проверяет блокировку файла department/4111 и переходит в ожидание, так как файл заблокирован вторым клиентом
    31) Второй клиент удаляет строку department/4111
    32) Второй клиент получает метаданные таблицы Job
    33) Второй клиент получает сканирует таблицу Job для нахождения строк со ссылкой на department/4111
    34) Второй клиент проверяет блокировку файла Job/2111. Файл заблокирован первым клиентом, поэтому второй клиент ожидает разблокировки
Оба клиента ожидают взаимной разблокировки требуемых ресурсов. Они заблокированы.


### 7.4 Удаления прав доступа к таблице
Первый клиент обновляет строки в таблице Department, потом в Employee. Второй клиент снимает с первого права на доступ к таблицам Department и Employee.
Структура базы данных до изменений для примера блокировки диапазона изменения индексов представлена на Рисунке 3.


Алгоритм:
    35) Первый клиент блокирует файл 4111 в таблице Department
    36) Первый клиент изменяет файл 4111 в таблице Department
    37) Второй клиент изменяет права доступа к таблице Employee и Department, запрещая первому клиенту доступ к ним
    38) Первый клиент пытается заблокировать строку 2111 в таблице Employee, но не может, так как у него нет прав на доступ к этой таблице.
Первый клиент не может заблокировать строку 2111 в таблице Employee, в следствии этого он не может завершить транзакцию и остаётся в заблокированном состоянии.
### 7.5 Блокировка диапазона индексов
Первый клиент блокирует изменяет файлы table/5 и table/15. Второй клиент изменяет файлы table/5, table/10, table/15. Для оптимизации блокировок клиент 2 блокирует узел 10.
Структура базы данных до изменений представлена на Рисунке 4.

Алгоритм:
    39) Первый клиент блокирует файл 5 в таблице Table и изменяет его
    40) Второй клиент блокирует узел 10 в индексном дереве
    41) Второй клиент пытается изменить файл 5, но не может сделать этого, так как файл 5 заблокирован клиентом 1
    42) Первый клиент пытается заблокировать для изменения файл 15, но не может этого сделать, так как один из его родительских узлов заблокирован
Клиент 1 ожидает разблокировки узла 10, занятый клиентом 2. В то время как клиент 2 ожидает разблокировки файла 5, который занят клиентом 1. Оба клиента ожидают взаимной разблокировки.
### 7.6 Синхронизация изменений между кластерами
Блокировка изменений кластера происходит только в пределах одного кластера.
Структура БД до изменений представлена на Рисунке 5.

Алгоритм:
    • Первый клиент блокирует файл 1111 в таблице table а первом кластере
    • Втором клиент блокирует файл 1111 в таблице table а втором кластере
    • Первый клиент изменяет файл 1111 в таблице table на первом кластере
    • Второй клиент изменяет файл 1111 в таблице table на втором кластере
    • Первый клиент получает список серверов, содержащих таблицу table
    • Второй клиент получает список серверов, содержащих таблицу table
    • Первый клиент пытается заблокировать файл 1111 в таблице table на втором кластере для репликации своих изменений, но не может этого сделать, так как строка заблокирована клиентом 2
    • Второй клиент пытается заблокировать файл 1111 в таблице table на первом кластере для репликации своих изменений, но не может этого сделать, так как строка заблокирована клиентом 1
Клиент 1 ожидает разблокировки файла на кластере 2, в то время как клиент 2 ожидает разблокировки файла на первом кластере. Оба клиента не могут продолжать работу.
Следующим этапом работы будет моделирование данных алгоритмов в виде математических структур и их модификация для достижения состояния, когда возникновение тупиков в системе будет невозможно, но при этом будет поддерживаться транзакционность изменений а базе данных.
## 8 Список публикаций по теме работы
1. Питерсон Дж. Теория сетей Петри и моделирование систем. (Petri Net Theory and the Modeling of Systems, 1981) Перевод с английского М.В. Горбатовой, В.Л. Торхова, В.Н. Четверикова под редакцией В.А. Горбатова — Москва: Издательство «Мир». Редакция литературы по новой технике, 1984
2. Котов B.E. Сети Петри — Москва: Издательство «Наука»: Главная редакция физико-математической литературы, 1984
3. C. A. R. Hoare Communicating Sequential Processes — C. A. R. Hoare, 1985–2004
4. Bernstein, P.A.: VHaNG. Concurrency Control and Recovery in Database Systems. Addison Wesley (1987)
5. Ceri, S.P.G.: Distributed Database Principles and Systems. McGraw-Hill, New York (1984)
6. Chandy, M.M.J.H.L.: Distributed deadlock detection. ACM Trans. Comput. Syst. 1(2), 144–156 (1983)
7. RC H: Some Deadlock Properties in Computer Systems. ACM Comput. Surv. 4(3), 179–196 (1972)
8. Gray, J.R.A.: Transaction Processing: Concepts and Techniques San. Morgan Kaufmann Publ, Mateo: (1993)
9. Moss, J.E.B.: April. Nested Transactions: An Approach to Reliable Distributed Computing. Cambridge, MA:; (1981)
10. Bjork, L.A.: Recovery scenario for a DB/DC system. In ACM Annual Conference; pp. 142–6. (1973)
11. Davies, C.T.: Recovery semantics for a DB/DC system. In ACM Annual Conference; pp. 136–41. (1973)
12. Salem HGMaK. Sagas. In ACM SIGMOD International Conference on Management of Data: pp. 249–259. (1987)
13. Karabatis, G.: Nested Transaction Models. In: Liu, L., ÖM (eds.) Encyclopedia of Database Systems. Springer, New York (2017)
14. Medjahed, B.: MOAKE. Generalization of ACID Properties. In Liu L. ÖMT, editor. Encyclopedia of Database Systems; ; Boston, MA: Springer. (2009)
15. Buchmann, A.: Open Nested Transaction Models. In: Liu, L., ÖM (eds.) Encyclopedia of Database Systems. Springer, New York (2016)
16. Rothermel THaK: Concurrency Control Issue in Nested Transactions. VLDB J. 2(1), 39–74 (1993)
17. Härder, T.R.K.: Concurrency Control Issues in Nested Transactions. VLDB J. 2(1), 39–74 (1993)
18. M R. Hierarchical Deadlock Detection for Nested Transactions. Distrib. Comput. ; 4(3): 123–129. (1991)
19. Sinha, M.K.N.M.: A Priority Based Distributed Deadlock Detection Algorithm. IEEE Trans. Softw. Eng. 11(1), 67–80 (1985)
20. Rukoz, M.: A distributed solution for detecting deadlock in distributed nested transaction systems Bermond J,RM, editor. Berlin, Heidelberg: In Distributed Algorithms,Lecture Notes in Computer Science,Springer; (1989)
21. Meenu, meenu & Shanker, Udai. (2024). Optimizing Deadlock Detection Strategies for Nested Transactions in Complex Systems. 10.21203/rs.3.rs-5325205/v1.
22. S., Thenmozhi & T, Subaraksha. (2023). Breaking Deadlocks: A Novel Method for Dynamic Deadlock Resolution in Concurrent Systems. Journal of Advances in Shell Programming. 10. 10.37591/joasp.v10i3.765.
23. Zhang, Zijian & Hu, Hesuan. (2025). Deadlock Resolution in Networked Automated Manufacturing Systems With Communication Delays and Losses Using Petri Nets. IEEE Transactions on Systems, Man, and Cybernetics: Systems. PP. 1-15. 10.1109/TSMC.2025.3571500.
24. Uzam, Murat & Liu, Ding & Berthomieu, Bernard & Gelen, Gökhan & Zhang, Zhaolong & Mostafa, Almetwally & Li, Zhiwu. (2024). On Deadlock Livelock Studies Based on Reachability Graph of Petri Nets by Using TINA. IEEE Access. 12. 135506-135534. 10.1109/ACCESS.2024.3461168.
25. Manakhari, Sushanth & Jadhav, Ajinkya & Paraye, Twinkle & Gate, Anurag. (2024). Advanced Deadlock Detection and Resolution in Distributed File Systems Using AI and Daemon Processes. 3983-3991. 10.1109/BigData62323.2024.10825599.
26. Vij, Palak & Nikam, Sayali & Dua, Amit. (2022). A Survey of Deadlock Detection Algorithms. 10.1007/978-981-16-9012-9_51.
27. Fritchey, Grant. (2022). Causes and Solutions For Deadlocks. 10.1007/978-1-4842-8891-7_17.
28. Adobbati, Federica & Mikulski, Łukasz. (2025). Asynchronous Multi-Agent Systems with Petri nets. 10.48550/arXiv.2504.00602.
29. Li, Chengzong & Jin, Fubao & Chen, Yufeng & Li, Zhiwu & Uzam, Murat & Ma, Huimin. (2025). Calculation and Analysis of Petri Net Reachability Graphs by a Think-Globally-Act-Locally Method. Mathematics. 13. 793: 1-15. 10.3390/math13050793.
30. Jensen, Nicolaj & Larsen, Kim & Srba, Jiří. (2025). Token Elimination in Model Checking of Petri Nets. 10.1007/978-3-031-90643-5_11.
31. Zhai, Qianlong & Hu, Xin & El-Sherbeeny, Ahmed & Li, Zhiwu. (2024). A Deadlock Prevention Strategy for Petri Nets Through Tuning Time Constraints. IEEE Access. PP. 1-1. 10.1109/ACCESS.2024.3408637.