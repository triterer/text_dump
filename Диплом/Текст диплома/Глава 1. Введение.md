Глава 1. Введение
========================

## 1 Актуальность темы
В современной индустрии управления данными доминируют несколько парадигм: реляционная, документоориентированная, графовая и ключ-значение. Однако для хранения структурированных бизнес-процессов и обеспечения транзакционной целостности чаще всего выбираются реляционные (RDBMS) или документные (NoSQL) базы данных. Каждая из этих моделей обладает критическими компромиссами, определяющими область их применения.

Реляционные БД строятся на принципе жесткой структуризации, что гарантирует высокую консистентность данных. Несмотря на преимущества при чтении и агрегации, данный подход накладывает ограничения на гибкость разработки: любые изменения структуры требуют дорогостоящих процедур миграции. Кроме того, традиционные RDBMS ориентированы преимущественно на вертикальное масштабирование. С точки зрения конкурентного доступа, механизмы обеспечения ACID и строгой изоляции транзакций порождают проблему интенсивных блокировок, которые становятся «узким местом» при росте нагрузки.

Документные БД, напротив, ориентированы на работу со слабоструктурированными данными (Schema-on-read) и горизонтальное масштабирование. Это решает проблему гибкости, однако переносит сложность контроля целостности на уровень приложения, что увеличивает риск нарушения логической связности данных. Главным недостатком большинства таких систем является отсутствие полноценной поддержки распределенных транзакций и, как следствие, переход к модели согласованности в конечном счете (Eventual Consistency).

Целью данной работы является разработка распределенной документно-реляционной базы данных, совмещающей гибкость хранения документов с мощными механизмами контроля целостности, присущими реляционным системам. Предлагаемый подход позволяет хранить данные в виде иерархических структур без необходимости глобальных миграций при изменении схемы, обеспечивая при этом выполнение требований ACID.

Ключевой проблемой при реализации такой системы в распределенной среде является управление иерархическими блокировками. Ошибки в проектировании механизмов синхронизации в распределенных системах неизбежно приводят к состояниям взаимной блокировки (deadlock).

## 2 Разработанность темы
Проблема возникновения взаимных блокировок в системах с взаимодействующими параллельными процессами является классической задачей Computer Science. Исследования в области обнаружения и предотвращения тупиковых состояний в абстрактных моделях параллельных систем представлены в работах таких ученых, как С. Тенможи, Р. Т. Субаракша, Ф. Адоббати и Л. Микульски. В контексте систем управления базами данных (СУБД) данные вопросы получили развитие в трудах М. Мину, У. Шанкера, С. Манаркхи, А. Ядхава, Т. Парае и А. Гейта. Предложенные ими методы варьируются от классического построения графов ожидания (Wait-for-Graph) до применения алгоритмов машинного обучения для предиктивного анализа состояний транзакций.

Фундаментальный базис для данной работы составляют исследования в области формальных методов описания и верификации систем. В частности:
- Теория сетей Петри, развитая в работах Дж. Питерсона и В. Котова, используется для моделирования динамики распределенных систем.
- Исчисление взаимодействующих последовательных процессов Ч. Хоара выступает в качестве математического аппарата для формального описания протоколов обмена сообщениями.

Применимость данных теоретических моделей для решения прикладных задач проектирования сложных программных комплексов подтверждается современными исследованиями Ч. Кианлонга, Х. Чи и А. Эль-Шербини.

Несмотря на наличие глубокой теоретической базы, анализ работ признанных экспертов в области распределенных систем — П. Бернштейна, С. Цери и К. Чанди — позволяет выделить ряд направлений, требующих дальнейшей проработки применительно к документно-реляционным моделям:
- Предиктивное избежание блокировок: переход от реактивного обнаружения (detection) и разрешения (resolution) тупиков к проектированию систем, формально исключающих возможность вхождения в клинч на этапе исполнения.
- Иерархическая синхронизация при эволюции схемы: классические методы блокировок часто избыточны для полуструктурированных данных. Необходима разработка механизмов, способных динамически адаптировать уровень блокировки (от поля до документа) на основе актуальной схемы коллекции.
- Оптимизация распределенного консенсуса: минимизация количества раундов обмена сообщениями при согласовании блокировок в распределенной среде, что критически важно для сокращения задержек (latency) в транзакционных системах.

Анализ существующих подходов показывает, что интеграция методов формальной верификации и динамического вывода схем данных открывает возможности для создания высокопроизводительных распределенных DLM-модулей, что и определяет вектор данного исследования.

## 3 Цель работы
Целью данной работы является проектирование и реализация архитектуры распределенной документно-реляционной базы данных, а также разработка механизмов управления иерархическими блокировками, гарантирующих отсутствие тупиковых состояний (deadlocks) на основе методов формальной верификации.
## 4 Задачи
Для достижения поставленной цели необходимо решить следующие задачи:
1. Провести системный анализ предметной области и существующих подходов к управлению блокировками в распределенных СУБД, выявив потенциальные сценарии возникновения взаимных блокировок.
2. Разработать алгоритм динамического вывода схемы  и структуру иерархического хранения путей на основе Префиксных деревьев для оптимизации гранулярности блокировок.
3. Формализовать алгоритмы функционирования распределенного менеджера блокировок с использованием нотации взаимодействующих последовательных процессов.
4.  Синтезировать математические модели системы на базе сетей Петри для анализа динамического поведения процессов и проверки условий достижимости тупиковых состояний.
5. Верифицировать и оптимизировать разработанные модели, предложив методы предотвращения взаимных блокировок на этапе проектирования алгоритмов.
## 5 Объект и предмет исследования
Объектом исследования являются процессы функционирования и реализации распределенных систем управления базами данных, совмещающих документоориентированную и реляционную модели данных.

Предметом исследования выступают алгоритмы обеспечения транзакционной целостности, механизмы иерархической синхронизации доступа и методы формальной верификации параллельных процессов, исключающие возникновение тупиковых состояний в распределенной среде.
## 6 Анализ предметной области
Концепция документно-реляционных баз данных представляет собой попытку синтеза гибкости NoSQL-систем и строгих гарантий классических RDBMS. Несмотря на актуальность задачи, на рынке представлено ограниченное число зрелых решений, среди которых наиболее показательны экосистема Hadoop (в связке с Hive) и СУБД FaunaDB.

Экосистема Hadoop (HDFS и Apache Hive) реализует подход «Schema-on-Read». HDFS обеспечивает иерархическое хранение файлов произвольных форматов, а Hive предоставляет SQL-интерфейс (HiveQL) для их обработки. Данный стек ориентирован на OLAP-нагрузки (аналитику) и обладает существенными ограничениями в транзакционном контексте. Механизмы блокировок в Hive реализованы на уровне таблиц или разделов, что не позволяет достичь гранулярности на уровне отдельного документа или поля. Отсутствие полноценной поддержки ACID в реальном времени приводит к низкой эффективности при интенсивных конкурентных изменениях данных.

FaunaDB является наиболее близким аналогом полноценной документно-реляционной СУБД. Она обеспечивает ACID-гарантии и использует собственный язык запросов FQL. В основе ее архитектуры лежит протокол Calvin, который обеспечивает детерминированное упорядочивание транзакций. Протокол Calvin требует предварительного анализа набора данных, к которым обращается транзакция (read/write sets), что затрудняет работу с динамически меняющимися структурами документов. Хотя использование логических порядковых номеров вместо системных часов решает проблему дрейфа времени, это создает зависимость от централизованного модуля планирования, что может стать узким местом по задержкам (latency).

Анализ указанных систем показывает, что существующие решения либо жертвуют транзакционностью ради масштабируемости (Hadoop), либо накладывают жесткие ограничения на процесс планирования транзакций (FaunaDB). В данной работе предлагается альтернативный путь:  применение Distributed Lock Manager на базе префиксных деревьев. Для обеспечения надежности такого подхода и исключения рисков, связанных с распределенными блокировками, критически важно использование формальных методов моделирования, таких как сети Петри и алгоритмическая алгебра CSP.
## 7 Список примеров возможных взаимных блокировок
В рамках предварительного исследования архитектуры системы были идентифицированы критические сценарии, при которых конкурентный доступ к данным может привести к полной остановке процессов вследствие возникновения тупиковых состояний. Основное внимание уделено ситуациям, в которых менеджер блокировок сталкивается с циклической зависимостью транзакций.
### 7.1 Взаимоисключающие изменения двух клиентов
В данном сценарии рассматривается взаимодействие двух параллельных транзакций, оперирующих данными в реляционных структурах. Начальное состояние структуры данных и связи между объектами через внешние ключи представлены на рисунке 1.

![petri_db-Две записи схема](../../media/petri_db-%D0%94%D0%B2%D0%B5%20%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B8%20%D1%81%D1%85%D0%B5%D0%BC%D0%B0-1.png)

Для обеспечения изоляции операций применяются эксклюзивные (X) и разделяемые (S) блокировки. Взаимодействие между типами блокировок определяется матрицей совместимости, представленной в таблице 1, где положительный маркер указывает на возможность одновременного удержания блокировок разными субъектами доступа.

Есть/требуется | S | X
---|---|---
S | + | -
X | - | -

Рассматриваемая модель включает две транзакции (T1​ и T2​), инициированные одновременно. Первая транзакция (T1​) направлена на модификацию записи в таблице worker с идентификатором 1111 (обновление должности сотрудника), в то время как вторая (T2​) производит изменение в таблице job для записи с идентификатором 2111.

Алгоритм:
1. T1​ проверяет блокировку строки worker/1111;
2. T1​ блокирует строку worker/1111 с меткой X;
3. T2​ проверяет блокировку строки job/2111;
4. T2​ блокирует строку job/2111 с меткой X;
5. T1​ получает от строки worker/1111 внешний ключ job/2111;
6. T1​ проверяет блокировку строки job/2111;
7. T1​ ожидает разблокировки строки job/2111, так как не может разместить блокировку S совместно с меткой X;
8. T2​ получает от строки job/2111 внешний ключ worker/1111
9. T2​ проверяет блокировку строки worker/1111, так как не может разместить блокировку S совместно с меткой X
10. T2​ ожидает разблокировки строки worker/1111


Результат: Обе транзакции удерживают эксклюзивные блокировки X на строках в таблицах и ожидают получения разделяемых блокировок S на строках оппонента. Возникает дедлок системы.


### 7.2 Эскалация блокировок
В этом сценарии будет рассматриватся объект исследования в виде коллекции numbers, содержащей упорядоченное множество числовых значений. Пример такого объекта представлен на рисунке 2.

![my_db_v2-deadlock db examples](../../media/my_db_v2-deadlock%20db%20examples.png)

Взаимодействие транзакций регулируется использованием интенционных эксклюзивных (IX) и эксклюзивных (X) блокировок. Интенционный режим указывает на намерение транзакции модифицировать объекты на более низких уровнях иерархии, что позволяет системе эффективно координировать доступ к родительским узлам. Матрица совместимости данных типов блокировок приведена в таблице 2.

Есть/требуется | IX | X
---|---|---
IX | + | -
X | - | -

В рассматриваемой модели транзакция T1​ выполняет инкремент значений в диапазоне от 1 до 100, в то время как транзакция T2​ обрабатывает диапазон от 101 до 200. В соответствии с алгоритмом работы системы, обе транзакции начинают выполнение с установления блокировок типа IX на уровне всей коллекции numbers. Поскольку режим IX совместим сам с собой, обе транзакции успешно входят в критическую секцию и приступают к последовательной модификации элементов, накладывая на каждый из них индивидуальную блокировку типа X.

Алгоритм:
1. T1​ проверяет блокировку коллекции numbers
2. T1​ захватывает блокировку IX коллекции numbers
3. T2 проверяет блокировку коллекции numbers
4. T2 проверяет блокировку IX коллекции numbers, так как это блокировка совместима с уже установленной блокировокой IX транзакции T1
5. T1 проверяет блокировку элемента 1
6. T1 захватывает блокировку X элемента 1
7. T2 Проверяет блокировку элемента 101
8. T2 захватывает блокировку X элемента 101
9.  T1 проверяет блокировку элемента 2
10. T1 захватывает блокировку X элемента 2
11. T2 Проверяет блокировку элемента 102
12. T2 захватывает блокировку X элемента 102
...
200. T1 проверяет блокировку элемента 50
201. T1 захватывает блокировку X элемента 50
202. T2 Проверяет блокировку элемента 150
203. T2 захватывает блокировку X элемента 150
204. T1 переходит к эскалации блокировки и проверяет блокировку коллекции numbers
205. T1 ожидает разблокировки коллекции, так как блокировка X не совместима с блокировкой IX
206. T2 переходит к эскалации блокировки и проверяет блокировку коллекции numbers
207. T2 ожидает разблокировки коллекции, так как блокировка X не совместима с блокировкой IX

Результат: Обе транзакции не могут разместить эксклюзивные блокировки X на коллекциях ввиду наличия интенционных блокировок IX оппонента. Возникает дедлок системы.

### 7.3 Синхронизация изменений между кластерами
Для анализа процессов синхронизации рассматривается топология из двух узлов, на каждом из которых размещена реплика таблицы Table. Начальное состояние структуры данных и связи между объектами через внешние ключи представлены на рисунке 3.

![petri_db-Репликация Схема](../../media/petri_db-%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0-1.png)


Взаимодействие транзакций регулируется исключительно эксклюзивными блокировками типа X, при этом область действия каждой блокировки ограничена сервером, на котором она была зарегистрирована.

Сценарий инициируется поступлением двух независимых транзакций, T1​ и T2​, на разные узлы кластера. Транзакция T1​ на первом сервере стремится обновить поле value записи с идентификатором 1, в то время как транзакция T2​ на втором сервере инициирует изменение того же поля для той же записи. В отсутствие глобального координатора блокировок обе операции начинают выполнение параллельно.

Алгоритм:
1. T1 проверяет блокировку строки table/1 на сервере 1
2. T1 захватывает блокировку X на строку table/1 на сервере 1
3. T1 изменяет значение поля value на сервере 1
4. T2 проверяет блокировку строки table/1 на сервере 2
5. T2 захватывает блокировку X на строку table/1 на сервере 2
6. T2 изменяет значение поля value на сервере 2
7. T1 проверяет блокировку строки table/1 на сервере 2
8. T1 ожидает разблокировки строки на сервере 2, так как блокировка X не совместима с X
9. T2 проверяет блокировку строки table/1 на сервере 1
10. T2 ожидает разблокировки строки на сервере 1 , так как блокировка X не совместима с X
Транзакция 1 ожидает разблокировки стоки на сервере 2, в то время как транзакция 2 ожидает разблокировки строки на первом сервере. Оба клиента не могут продолжать работу.



Следующим этапом работы будет моделирование данных алгоритмов в виде математических структур и их модификация для достижения состояния, когда возникновение тупиков в системе будет невозможно, но при этом будет поддерживаться транзакционность изменений а базе данных.

### 7.6 Проблемы middle to bottom блокировок?
### 7.7 Блокировки с join или where?
### 7.8 Блокировки поддержания консистентности?
### 7.2 Эволюция схемы
### 7.4 Блокировка диапазона индексов
## 8 Список публикаций по теме работы
1. Питерсон Дж. Теория сетей Петри и моделирование систем. (Petri Net Theory and the Modeling of Systems, 1981) Перевод с английского М.В. Горбатовой, В.Л. Торхова, В.Н. Четверикова под редакцией В.А. Горбатова — Москва: Издательство «Мир». Редакция литературы по новой технике, 1984
2. Котов B.E. Сети Петри — Москва: Издательство «Наука»: Главная редакция физико-математической литературы, 1984
3. C. A. R. Hoare Communicating Sequential Processes — C. A. R. Hoare, 1985–2004
4. Bernstein, P.A.: VHaNG. Concurrency Control and Recovery in Database Systems. Addison Wesley (1987)
5. Ceri, S.P.G.: Distributed Database Principles and Systems. McGraw-Hill, New York (1984)
6. Chandy, M.M.J.H.L.: Distributed deadlock detection. ACM Trans. Comput. Syst. 1(2), 144–156 (1983)
7. RC H: Some Deadlock Properties in Computer Systems. ACM Comput. Surv. 4(3), 179–196 (1972)
8. Gray, J.R.A.: Transaction Processing: Concepts and Techniques San. Morgan Kaufmann Publ, Mateo: (1993)
9. Moss, J.E.B.: April. Nested Transactions: An Approach to Reliable Distributed Computing. Cambridge, MA:; (1981)
10. Bjork, L.A.: Recovery scenario for a DB/DC system. In ACM Annual Conference; pp. 142–6. (1973)
11. Davies, C.T.: Recovery semantics for a DB/DC system. In ACM Annual Conference; pp. 136–41. (1973)
12. Salem HGMaK. Sagas. In ACM SIGMOD International Conference on Management of Data: pp. 249–259. (1987)
13. Karabatis, G.: Nested Transaction Models. In: Liu, L., ÖM (eds.) Encyclopedia of Database Systems. Springer, New York (2017)
14. Medjahed, B.: MOAKE. Generalization of ACID Properties. In Liu L. ÖMT, editor. Encyclopedia of Database Systems; ; Boston, MA: Springer. (2009)
15. Buchmann, A.: Open Nested Transaction Models. In: Liu, L., ÖM (eds.) Encyclopedia of Database Systems. Springer, New York (2016)
16. Rothermel THaK: Concurrency Control Issue in Nested Transactions. VLDB J. 2(1), 39–74 (1993)
17. Härder, T.R.K.: Concurrency Control Issues in Nested Transactions. VLDB J. 2(1), 39–74 (1993)
18. M R. Hierarchical Deadlock Detection for Nested Transactions. Distrib. Comput. ; 4(3): 123–129. (1991)
19. Sinha, M.K.N.M.: A Priority Based Distributed Deadlock Detection Algorithm. IEEE Trans. Softw. Eng. 11(1), 67–80 (1985)
20. Rukoz, M.: A distributed solution for detecting deadlock in distributed nested transaction systems Bermond J,RM, editor. Berlin, Heidelberg: In Distributed Algorithms,Lecture Notes in Computer Science,Springer; (1989)
21. Meenu, meenu & Shanker, Udai. (2024). Optimizing Deadlock Detection Strategies for Nested Transactions in Complex Systems. 10.21203/rs.3.rs-5325205/v1.
22. S., Thenmozhi & T, Subaraksha. (2023). Breaking Deadlocks: A Novel Method for Dynamic Deadlock Resolution in Concurrent Systems. Journal of Advances in Shell Programming. 10. 10.37591/joasp.v10i3.765.
23. Zhang, Zijian & Hu, Hesuan. (2025). Deadlock Resolution in Networked Automated Manufacturing Systems With Communication Delays and Losses Using Petri Nets. IEEE Transactions on Systems, Man, and Cybernetics: Systems. PP. 1-15. 10.1109/TSMC.2025.3571500.
24. Uzam, Murat & Liu, Ding & Berthomieu, Bernard & Gelen, Gökhan & Zhang, Zhaolong & Mostafa, Almetwally & Li, Zhiwu. (2024). On Deadlock Livelock Studies Based on Reachability Graph of Petri Nets by Using TINA. IEEE Access. 12. 135506-135534. 10.1109/ACCESS.2024.3461168.
25. Manakhari, Sushanth & Jadhav, Ajinkya & Paraye, Twinkle & Gate, Anurag. (2024). Advanced Deadlock Detection and Resolution in Distributed File Systems Using AI and Daemon Processes. 3983-3991. 10.1109/BigData62323.2024.10825599.
26. Vij, Palak & Nikam, Sayali & Dua, Amit. (2022). A Survey of Deadlock Detection Algorithms. 10.1007/978-981-16-9012-9_51.
27. Fritchey, Grant. (2022). Causes and Solutions For Deadlocks. 10.1007/978-1-4842-8891-7_17.
28. Adobbati, Federica & Mikulski, Łukasz. (2025). Asynchronous Multi-Agent Systems with Petri nets. 10.48550/arXiv.2504.00602.
29. Li, Chengzong & Jin, Fubao & Chen, Yufeng & Li, Zhiwu & Uzam, Murat & Ma, Huimin. (2025). Calculation and Analysis of Petri Net Reachability Graphs by a Think-Globally-Act-Locally Method. Mathematics. 13. 793: 1-15. 10.3390/math13050793.
30. Jensen, Nicolaj & Larsen, Kim & Srba, Jiří. (2025). Token Elimination in Model Checking of Petri Nets. 10.1007/978-3-031-90643-5_11.
31. Zhai, Qianlong & Hu, Xin & El-Sherbeeny, Ahmed & Li, Zhiwu. (2024). A Deadlock Prevention Strategy for Petri Nets Through Tuning Time Constraints. IEEE Access. PP. 1-1. 10.1109/ACCESS.2024.3408637.