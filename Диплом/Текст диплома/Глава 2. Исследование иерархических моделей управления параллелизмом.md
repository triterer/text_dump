Глава 2. Исследование иерархических моделей управления параллелизмом
========================

## 2.1. Формальное представление древовидных структур данных
В документно-ориентированных базах данных данные обладают естественной иерархической вложенностью. Однако традиционные методы управления конкурентным доступом зачастую рассматривают документ как неделимую (атомарную) единицу, игнорируя его внутреннюю структуру. В отличие от жестко типизированных кортежей реляционной модели, документ в формате JSON (JavaScript Object Notation) обладает свойством самоописания (self-describing). Математически это выражается через рекурсивное определение: объект O есть отображение множества ключей K на множество значений V, где V∈{S∪O∪A} (S — скаляры, A — массивы).

Традиционный подход (Baseline) ограничивает уровень гранулярности корнем дерева *Vroot*​. Это приводит к возникновению ложных конфликтов (false conflicts), когда две независимые транзакции *T1*​ и *T2*​ адресуют непересекающиеся подмножества узлов *Vi​⊂V* и *Vj​⊂V*, но блокируются на уровне *Vroot*​. Для примера рассмотрим документ JSON (JavaScript Object Notation) представленный в листинге 2.1.1.
```
{
  "name": "Jason",
  "age": 39,
  "height": 1.92,
  "gender": "M",
  "married": true,
  "traits": ["lazy", "body modder"],
  "body parts": {
    "head": "normal",
    "left arm": "normal",
    "right arm": "missing",
    "left leg": "peg leg",
    "right leg": "archotech leg"
  },  "children": [
    {"name": "Tom", "age": 9},
    {"name": "Ava", "age": 7}
  ]
}
```

В рамках этой модели любая операция записи (*Write*) требует захвата эксклюзивной блокировки (*X*) на весь JSON-объект, а операция чтения (*Read*) — разделяемой блокировки (*S*). Математически это можно представить как неделимый ресурс. При поступлении запроса от транзакции *T1* на изменение поля *name* и запроса от транзакции *T2* на изменение поля *children* в рамках одного документа, возникает конфликт доступа, даже если поля *name* и *children* независимы.

## 2.2. Анализ эталонной модели (Baseline): Блокирование на уровне документа

Для проведения объективного исследования и последующей оценки эффективности предлагаемых решений необходимо определить базовую модель (**baseline**), относительно которой будет производиться сравнение. В качестве эталона принята модель эксклюзивного блокирования объектов (Single-Level Locking). В данной модели гранулярность блокировки ограничена корнем дерева Vroot​. Для распределенной среды данный метод реализуется через централизованный или распределенный менеджер блокировок, который оперирует уникальными идентификаторами документов (Universally Unique IDentifier). Это приводит к возникновению ложных конфликтов (false conflicts). Рассмотрим ситуацию, когда транзакция T1​ модифицирует поле name, а T2​ — поле children. Несмотря на то, что множества затрагиваемых узлов не пересекаются (VT1​∩VT2​=∅), обе транзакции конкурируют за блокировку корня Vroot​, что приводит к последовательному выполнению вместо параллельного.

Построим описание работы этой модели. Для строгого математического описания взаимодействия процессов в системе воспользуемся формализмом взаимодействующих последовательных процессов (CSP) Ч.Э. Хоара. Рассматривая документ как ресурс, а транзакции как взаимодействующие последовательные процессы. Сначала определим алфавит событий α, в которых может участвовать процесс документа DOC. Для модели Single-Level Locking эти алфавиты минималены:

αDOC = (acquire_uuid_X,acquire_uuid_S,release_uuid)
αT = (acquire_uuid_X,acquire_uuid_S,release_uuid,read,write)

Где:
- *acquire_uuid_X* — захват эксклюзивного доступа;
- *acquire_uuid_S* — захват Разделяемого доступа;
- *release_uuid* — освобождение ресурса;
- *read* — чтение данных из ресурса;
- *write* - изменение данных в ресурсе.

Ресурс DOC в таком случае описывается как:

DOC = (acquire_uuid_X -> release | μrelease:{acquire_uuid_S}∙(acquire_uuid_S -> release_uuid)) -> DOC

Здесь критически важно, что после события acquire процесс DOC отказывается участвовать в любых других событиях acquire до тех пор, пока не произойдет событие release. Теперь опишем процессы транзакций следующим образом:

T1 = acquire_uuid_X -> write -> release_uuid -> SKIP
T2 = acquire_uuid_S -> read -> release_uuid -> SKIP

Рассмотрим систему SYSTEM=(T1​∣∣T2​∣∣DOC). Если процесс T1​ первым выполняет событие синхронизации lock_X с DOC, то система переходит в состояние, где для T2​ событие lock_S недоступно. Теперь процесс DOC находится в состоянии, где его алфавит доступных действий ограничен: {read,write,release_uuid}. В этот момент репертуар αDOC∩αT2 = ∅. Возникает состояние ожидания (Wait), обусловленное блокировкой всего ресурса. Соответсвенно в работе процесса T2 возникает задержка до тех пор, пока процесс два не выполнит операцию release_uuid. Несмотря на то что транзакции могли в этот момент взаимодействовать с непересекающимися частями документа. А значит могли потенциально работать совместно.

Наиболее критичным недостатком модели является высокий риск возникновения взаимоблокировок при работе с множеством документов. Пусть в системе существуют два документа DOC1​ и DOC2​.

DOCi = (acquire_uuidi.j_X -> write -> release | μrelease:{acquire_uuidi.j_S}∙(acquire_uuidi.j_S -> read -> release_uuidi.j)) -> DOCi

Рассмотрим две транзакции, обращающиеся к документам в перекрестном порядке:

Tj = acquire_uuidi.j_X -> acquire_uuidi.j_X -> write -> release_uuidi.j -> release_uuidi.j -> SKIP

При параллельном исполнении SYSTEM=(T1​∣∣T2​∣∣DOCA​∣∣DOCB​) возможна трасса событий s=⟨T1​.lock_XA​, T2​.lock_XB​⟩. В этом состоянии:
- T1​ ожидает события lock_XB​, которое невозможно, так как DOCB​ захвачен T2​.
- T2​ ожидает события lock_XA​, которое невозможно, так как DOCA​ захвачен T1​.

Алфавит возможных действий системы становится пустым (αSYSTEM=∅), что эквивалентно состоянию STOP (Deadlock). Для решения этих проблем требуется переход к многоуровневому протоколу (Multiple Granularity Locking — MGL), позволяющему блокировать ресурсы на уровне поддеревьев, а не всего графа.

## 2.3 Адаптация протокола MGL для документно-реляционных моделей

В отличие от реляционных СУБД со статической иерархией (База → Таблица → Страница → Строка), документные БД часто ограничивают иерархию уровнем файла.

Для повышения параллелизма предлагается внедрение гибридной иерархии блокировок: документно-реляционной базы данных что позволит повысить гранулярность блокировок вплоть до отдельных полей (База -> Коллекция -> Файл -> Путь). Для примера можно представить приведённый выше документ в виде графа, представленного на рисунке 2.3.1.

![json_as_graph](../../media/json_graph.png)

В данной модели каждый узел дерева становится независимым разделяемым ресурсом, идентифицируемым через Путь (P). Путь определяется как упорядоченный кортеж ключей от корня до целевого узла:

P=⟨k1​,k2​,…,kn​⟩

Для работы менеджера блокировок (Lock Manager) данный кортеж сериализуется в уникальный строковый идентификатор ресурса, например: R_James.body_parts.left_arm. Таким образом, транзакция, работающая с веткой body parts, не блокирует транзакцию, работающую с веткой children, так как их пути P1​ и P2​ не имеют общих префиксов ниже уровня корня.

Однако для формирования гранулярных блокировок на более детальном уровне чем файлы требуется подход который применяется в менеджерах блокировок реляционных баз данных. Но для его применения требуется наличия заведомо предопределённой структуры всех хранимых данных, которая традиционно отсутсвует в документо-ориентированных базах данных. Для решения этой задачи применяется метод Schema Inference (вывод схемы).

### Schema Inference
В отличие от реляционной модели, здесь схема S не задается администратором, а является функцией от множества сохраненных документов. Документ JSON обладает свойством самоописания. Математически это выражается через рекурсивное определение типов. При анализе подобного определения можно сформировать промежуточный абстрактный слой - схему (Schema, S). Поскольку в коллекции могут хранится файлы с разной внутреней структурой, то необходимо будет разработать алгоритм формирования схемы, который сможет выполнять следующие операции:
- Инспекция путей: При формировании или обновлении схемы​ система выполняет рекурсивный обход дерева ключей, формируя множество путей Pnew​=⟨p1​,p2​,…,pn⟩​.
- Определение типов: Для каждого сформированного пути необходимо определять тип узла.
- Слияние: Текущий прототип коллекции S_coll​ обновляется путем теоретико-множественного объединения с путями нового документа: S`_coll ​= S_coll ​∪ P_new​.
- Разрешение конфликтов типов: При обхединении множеств путей иметь возможность создавать структурные объединения при конфликте типов в ресурсах при объединении.

Задача обхода путей и формирования схемы рассматривается в работе "Schema Inference for Massive JSON Datasets". Но к сожалению решения предложенные в ней нам не подойдут, так как предназначаются они в первую очередь для анализа больших архивов в формате OnLine Analytical Processing (OLAP), которые не предполагают высокой интерактивности при работе с данными, а вывод схемы происходит при обраюотке запросов (batch processing). Однако в данной диссертации предлагается модификация указанных подходов для локального вывода иерархии ресурсов. Использование рекурсивного обхода дерева, аналогичного описанному в [Buneman, 1997], позволяет сформировать дескрипторы путей, которые становятся базисом для иерархического протокола блокировок. В соответсвии с ней схема будет формироватся как ориентированное дерево *T=(V,E)*, где:
- V — множество узлов, представляющих атрибуты или вложенные объекты. Множество V является объединением непересекающихся подмножеств: V = Vscal ​∪ Vcoll​, где:
    - Vscal​ — терминальные узлы, содержащие скалярные значения (числа, строки, булевы типы);
    - Vcoll​ — структурные узлы (объекты, массивы), определяющие контекст для дочерних элементов.
- E - множество связей, определяющих вложенность.

Это позволяет строить дерево блокировок динамически, расширяя его по мере поступления новых полей в документах, что согласуется с теорией решеток типов (type lattices). Но при таком подходе одной из проблем инференса в NoSQL моделях является полиморфизм типов, при котором идентичные пути pi​ в различных документах могут соответствовать как терминальным (Vscal​), так и структурным (Vcoll​) узлам.

Для обеспечения корректности протокола MGL в условиях коллизий предлагается концепция гибридного узла ресурса. В случае обнаружения конфликта типов при слиянии схем Scoll′​= Scoll ​∪ Pnew​, узел графа переводится в состояние полиморфного дескриптора. При этом любая операция над вложенными атрибутами полиморфного узла инициирует эскалацию блокировки на уровень выше, гарантируя изоляцию между документами с различной топологией одного и того же пути

---

### 1. Фундаментальные работы по выводу схем из JSON

Эти авторы первыми формализовали, как из набора документов получить строгую структуру.

* **Klettke, M., et al. (2015). "NoSQL Schema Extraction and Evolution".**
* **О чем:** Здесь исследуется, как схемы меняются со временем.
* **Как использовать:** Это идеальная ссылка для обоснования того, почему твои блокировки должны быть динамическими. Если структура документа меняется, статическая иерархия блокировок сломается, а твой Schema Inference её восстановит.

### 3. Современные NewSQL системы и их подход к схемам

Здесь ты связываешь теорию с практикой распределенных БД.

* **Di Scala, M., & Abadi, D. J. (2016). "Fully Transparent Online Schema Evolution".**
* **О чем:** Описывает, как менять структуру данных, не останавливая базу.
* **Как использовать:** Подчеркни, что твой метод вывода схемы позволяет реализовать «прозрачное» управление блокировками при изменении состава полей в документе.

### Пример оформления цитат в тексте Главе 2.2:

> «Задача извлечения структурных метаданных из полуструктурированных документов (Schema Inference) получила широкое освещение в работах [Baazizi et al., 2017] и [Klettke et al., 2015]. Традиционно данные методы применяются для построения глобальных схем коллекций. Однако в данной диссертации предлагается модификация указанных подходов для локального вывода иерархии ресурсов. Использование рекурсивного обхода дерева, аналогичного описанному в [Buneman, 1997], позволяет сформировать дескрипторы путей, которые становятся базисом для иерархического протокола блокировок».

---

 Для обеспечения корректности взаимодействия различных уровней иерархии вводятся интенционные типы блокировок:
* **IS (Intent Shared)** — намерение прочитать данные на необходимых для выполнения запроса узлах;
* **S (Shared)** — активное чтение данных узла;
* **IX (Intent Exclusive)** — намерение модифицировать данные на запрашиваемых узлах;
* **X (Exclusive)** — активное изменение данных на запрашиваемых узлах.

Совместимость данных типов блокировок определяется классической матрицей совместимости, представленной в таблице 2.1.1, в которой "Да" обозначает что блокировки совместимы (транзакции могут работать параллельно), а "Нет" — конфликт (вторая транзакция должна ждать).

УЖЕ ЕСТЬ / ПРОСИТ|IS|IX|S|X
---|---|---|---|---
IS|Да|Да|Да|Нет
IX|Да|Да|Нет|Нет
S|Да|Нет|Да|Нет
X|Нет|Нет|Нет|Нет

Однако её применение в распределенной среде для динамически изменяющихся схем требует специализированного алгоритма.


### DLM
Научный вес: «Конфликт транзакций T1​ и T2​ возникает тогда и только тогда, когда Path(vT1​) ∩ Path(vT2) = ∅».
### Распределённость
## 2.4 Формализация задачи через сети Петри (Начало)
## 2.7 Проведение «мысленного» или модельного эксперимента
## 2.8 Вывод