Глава 2. Исследование иерархических моделей управления параллелизмом
========================


## 2.1. Формальное представление древовидных структур данных

В документно-реляционных базах данных возникает специфическая проблема: данные обладают иерархической вложенностью, однако традиционные методы блокировок зачастую рассматривают документ как атомарную единицу. Формально представим документ *D* как ориентированное дерево *T=(V,E)*, где:
- V - множество узлов, представляющих атрибуты или вложенные объекты. При этом узлы *V* подразделяются на узлы *Vscal*, содержащие только скалярные значения (Числа, строки) и *Vcoll* узлы содержащие в себе любое число других узлов, которые могут как скалярными значениями, так и другими коллекциями;
- E - множество связей, определяющих вложенность.


Традиционный подход (Baseline) ограничивает уровень гранулярности корнем дерева *Vroot*​. Это приводит к возникновению ложных конфликтов (false conflicts), когда две независимые транзакции *T1*​ и *T2*​ адресуют непересекающиеся подмножества узлов *Vi​⊂V* и *Vj​⊂V*, но блокируются на уровне *Vroot*​. Для примера рассмотрим документ представленный в листинге 2.1.1.
```
{
  "name": "Jason",
  "age": 39,
  "height": 1.92,
  "gender": "M",
  "married": true,
  "traits": ["lazy", "body modder"],
  "body parts": {
    "head": "normal",
    "left arm": "normal",
    "right arm": "missing",
    "left leg": "peg leg",
    "right leg": "archotech leg"
  },  "children": [
    {"name": "Tom", "age": 9},
    {"name": "Ava", "age": 7}
  ]
}
```

В рамках этой модели любая операция записи (*Write*) требует захвата эксклюзивной блокировки (*X*) на весь JSON-объект, а операция чтения (*Read*) — разделяемой блокировки (*S*). Математически это можно представить как неделимый ресурс. При поступлении запроса от транзакции *T1* на изменение поля *name* и запроса от транзакции *T2* на изменение поля *children* в рамках одного документа, возникает конфликт доступа, даже если поля *name* и *children* независимы. Поэтому основными недостатками данного подхода можно выделить:
1. **Низкая степень параллелизма:** Блокировка всего документа при работе с его вложенными структурами создает неоправданные очереди.
2. **Избыточное ожидание:** Транзакции простаивают, ожидая освобождения ресурса, который фактически ими не затрагивается.

## 2.2. Анализ эталонной модели (Baseline): Блокирование на уровне документа

Для проведения объективного исследования и последующей оценки эффективности предлагаемых решений необходимо определить базовую модель (**baseline**), относительно которой будет производиться сравнение.

Построим описание работы этой модели.

Для оценки эффективности разрабатываемых методов в качестве эталона принята модель эксклюзивного блокирования объектов (Single-Level Locking). В распределенной среде данный метод реализуется через централизованный или распределенный менеджер блокировок (Distributed Lock Manager), который оперирует уникальными идентификаторами документов (Universally Unique IDentifier).

В рамках исследования этой модели выделяются следующие критические показатели:
- Коэффициент блокировки (Block Ratio): Отношение времени ожидания ресурса к общему времени выполнения транзакции.
- Вероятность конфликта: Функция от количества параллельных сессий и среднего размера документа.

В данной главе проводится моделирование базового алгоритма с использованием сетей Петри. Модель «базового захвата» строится на основе позиций *P={Pfree​,Pwait​,Pexec​}* и переходов *T={Req,Acq,Rel}*. Анализ этой модели в условиях высокой конкуренции (High Contention) позволяет выявить верхний предел масштабируемости классического подхода, который и будет служить отправной точкой для оценки предлагаемых улучшений.

## 2.3 Адаптация протокола MGL для документно-реляционных моделей


Переход от атомарного блокирования документа к иерархическому требует введения многоуровневого протокола блокировок (Multiple Granularity Locking — MGL). В отличие от классических реляционных СУБД, где иерархия статична (База -> Таблица -> Страница -> Строка), в документно-реляционной БД иерархия должна строиться адаптивно.

Для реализации этого подхода необходимо исследовать:
- Механизм интенционных состояний: Как захват части документа влияет на возможность блокировки документа целиком другими узлами кластера.
- Динамическую схему как граф ресурсов: Как изменения в структуре файлов в реальном времени должны отражаться в Schema Registry без остановки обслуживания запросов.

Для преодоления данных ограничений в работе предлагается переход к модели иерархических блокировок (Multiple Granularity Locking, MGL). В отличие от плоской структуры, MGL позволяет выстраивать дерево ресурсов, где блокировка узла более низкого уровня (например, коллекции) позволяет получать доступ на чтение и изменение частей одного документа двумя транзакициями независимо друг от друга. Для примера можно представить приведённый выше документ в виде графа, представленного на рисунке 2.1.1.

![json_as_graph](../../media/json_graph.png)

При преобразовании хранимых документов к такому формату становится возможным применения гранулярных блокировок и транзакции *T1* и *T2* смогут получить доступ к требуемым для них ресурсам независимо. В данной работе иерархия строится динамически на основе структуры документа. Для обеспечения корректности взаимодействия различных уровней иерархии вводятся интенционные типы блокировок:
* **IS (Intent Shared)** — намерение прочитать данные на необходимых для выполнения запроса узлах;
* **S (Shared)** — активное чтение данных узла;
* **IX (Intent Exclusive)** — намерение модифицировать данные на запрашиваемых узлах;
* **X (Exclusive)** — активное изменение данных на запрашиваемых узлах.

Совместимость данных типов блокировок определяется классической матрицей совместимости, представленной в таблице 2.1.1, в которой "Да" обозначает что блокировки совместимы (транзакции могут работать параллельно), а "Нет" — конфликт (вторая транзакция должна ждать).

УЖЕ ЕСТЬ / ПРОСИТ|IS|IX|S|X
---|---|---|---|---
IS|Да|Да|Да|Нет
IX|Да|Да|Нет|Нет
S|Да|Нет|Да|Нет
X|Нет|Нет|Нет|Нет

Однако её применение в распределенной среде для динамически изменяющихся схем требует специализированного алгоритма.

### Schema Inference
Проблема вывода схемы (Inference) (1 страница) Это как раз мостик к твоей «новизне».
- Опиши, что в классическом JSON схемы нет, но для иерархических блокировок нам нужно ее «угадать».
- Введи понятие «Прототипа схемы» (Schema Prototype), который строится на основе анализа множества документов.

В основе документно-ориентированного подхода лежит концепция полуструктурированных данных. В отличие от жестко типизированных кортежей реляционной модели, документ в формате JSON (JavaScript Object Notation) обладает свойством самоописания (self-describing). Математически это выражается через рекурсивное определение: объект O есть отображение множества ключей K на множество значений V, где V∈{S∪O∪A} (S — скаляры, A — массивы). Такая гибкость позволяет динамически изменять схему данных без простоя системы (zero-downtime schema evolution), что является критическим требованием для распределенных систем класса Big Data
### DLM
Научный вес: «Конфликт транзакций T1​ и T2​ возникает тогда и только тогда, когда Path(vT1​)∩Path(vT2​)=∅».
### важные моменты
- Введи понятие селектора пути (Path Selector). Пусть P=(k1​,k2​,…,kn​) — последовательность ключей, однозначно определяющая путь от корня к узлу.
- Разреженность данных: Объясни, что в JSON нет «пустых колонок» (null), как в SQL. Это экономит место в Big Data.
- Полиморфизм: В одной «таблице» (коллекции) документы могут иметь разную структуру.
### Распределённость
## 2.4 Формализация задачи через сети Петри (Начало)
## 2.5 Подготовка эталонного датасета
## 2.6 Математическое исследование Schema Inference
Опиши алгоритм вывода схемы как математическую функцию.
- Вход: Множество документов D={d1​,d2​,...,dn​}.
- Выход: Граф схемы G=(V,E), где узлы — это пути к полям (например, user.address.city).
- Докажи сложность алгоритма: Покажи, что вывод схемы не занимает больше времени, чем сама транзакция (это критично для производительности).
## 2.7 Проведение «мысленного» или модельного эксперимента
## 2.8 Вывод