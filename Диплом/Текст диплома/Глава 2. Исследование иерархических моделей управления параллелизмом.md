Глава 2. Исследование иерархических моделей управления параллелизмом
========================

## 2.1. Формальное представление древовидных структур данных

В документно-реляционных базах данных возникает специфическая проблема: данные обладают иерархической вложенностью, однако традиционные методы блокировок зачастую рассматривают документ как атомарную единицу. Формально представим документ *D* как ориентированное дерево *T=(V,E)*, где:
- V - множество узлов, представляющих атрибуты или вложенные объекты. При этом узлы *V* подразделяются на узлы *Vscal*, содержащие только скалярные значения (Числа, строки) и *Vcoll* узлы содержащие в себе любое число других узлов, которые могут как скалярными значениями, так и другими коллекциями;
- E - множество связей, определяющих вложенность.


Традиционный подход (Baseline) ограничивает уровень гранулярности корнем дерева *Vroot*​. Это приводит к возникновению ложных конфликтов (false conflicts), когда две независимые транзакции *T1*​ и *T2*​ адресуют непересекающиеся подмножества узлов *Vi​⊂V* и *Vj​⊂V*, но блокируются на уровне *Vroot*​. Для примера рассмотрим документ JSON (JavaScript Object Notation) представленный в листинге 2.1.1.
```
{
  "name": "Jason",
  "age": 39,
  "height": 1.92,
  "gender": "M",
  "married": true,
  "traits": ["lazy", "body modder"],
  "body parts": {
    "head": "normal",
    "left arm": "normal",
    "right arm": "missing",
    "left leg": "peg leg",
    "right leg": "archotech leg"
  },  "children": [
    {"name": "Tom", "age": 9},
    {"name": "Ava", "age": 7}
  ]
}
```

В рамках этой модели любая операция записи (*Write*) требует захвата эксклюзивной блокировки (*X*) на весь JSON-объект, а операция чтения (*Read*) — разделяемой блокировки (*S*). Математически это можно представить как неделимый ресурс. При поступлении запроса от транзакции *T1* на изменение поля *name* и запроса от транзакции *T2* на изменение поля *children* в рамках одного документа, возникает конфликт доступа, даже если поля *name* и *children* независимы.

## 2.2. Анализ эталонной модели (Baseline): Блокирование на уровне документа

Для проведения объективного исследования и последующей оценки эффективности предлагаемых решений необходимо определить базовую модель (**baseline**), относительно которой будет производиться сравнение. В качестве эталона принята модель эксклюзивного блокирования объектов (Single-Level Locking). Для распределенной среды данный метод реализуется через централизованный или распределенный менеджер блокировок, который оперирует уникальными идентификаторами документов (Universally Unique IDentifier).

Построим описание работы этой модели. Для строгого математического описания взаимодействия процессов в системе воспользуемся формализмом Энтони Хоара (Взаимодействующие паралельные процессы). Рассматривая документ как ресурс, а транзакции как взаимодействующие последовательные процессы. Сначала определим алфавит событий α, в которых может участвовать процесс документа DOC. Для модели Single-Level Locking этот алфавит минимален:

αDOC = (acquire_uuid_X,acquire_uuid_S,release_uuid,read,write)

Где:
- *acquire_uuid_X* — захват эксклюзивного доступа;
- *acquire_uuid_S* — захват Разделяемого доступа;
- *release_uuid* — освобождение ресурса;
- *read* — чтение данных из ресурса;
- *write* - изменение данных в ресурсе.

Ресурс DOC в таком случае описывается как:

DOC = (acquire_uuid_X -> write -> release | μrelease:{acquire_uuid_S}∙(acquire_uuid_S -> read -> release_uuid)) -> DOC

Здесь критически важно, что после события acquire процесс DOC отказывается участвовать в любых других событиях acquire до тех пор, пока не произойдет событие release. Теперь опишем процессы транзакций описываются следующим образом:
T1 = acquire_uuid_X -> write -> release_uuid -> SKIP
T2 = acquire_uuid_X -> read -> release_uuid -> SKIP

Пусть у нас есть два процесса транзакций T1​ и T2​, которые хотят взаимодействовать с одним и тем же документом.

SYSTEM=(T1||T2||DOC)

Если процесс T1​ первым синхронизируется с DOC по событию acquire_uuid_X, то состояние системы изменяется. Теперь процесс DOC находится в состоянии, где его алфавит доступных действий ограничен: {read,write,release_uuid}. В этот момент репертуар αDOC∩αT2 = ∅. Соответсвенно в работе процесса T2 возникает задержка до тех пор, пока процесс два не выполнит операцию release_uuid. Несмотря на то что транзакции могли в этот момент взаимодействовать с непересекающимися частями документа. А значит могли потенциально работать совместно. Так же ситуация может прийти в состояние deadlock, если ресурсов документа будет два:

DOCi = (acquire_uuidi.j_X -> write -> release | μrelease:{acquire_uuidi.j_S}∙(acquire_uuidi.j_S -> read -> release_uuidi.j)) -> DOCi

А процессы транзакций будут описыватся следующим образом:

Tj = acquire_uuidi.j_X -> acquire_uuidi.j_X -> write -> release_uuidi.j -> release_uuidi.j -> SKIP

В таком случае при работе системы:

SYSTEM=(T1||T2||DOC1||DOC2)

Возможно возникновение последовательности событий характеризующейся трейсом s = ⟨acquire_uuid1.1_X, acquire_uuid2.2_X⟩ в результате которого αSYSTEM=STOP. Для решения проблем этой модели блокировок требуется адаптация многоуровневого протокола блокировок (Multiple Granularity Locking — MGL) для работы с документами и доработки, которая предотвратит попадание в состояние deadlock системы при работе транзакций с несколькими ресурсами.

## 2.3 Адаптация протокола MGL для документно-реляционных моделей

В отличие от классических реляционных СУБД, где иерархия статична (База -> Таблица -> Страница -> Строка), в документных БД иерархия может строится только для гранулярности файлов (База -> Коллекция -> Файл). Поэтому для разработки многоуровневого протогола блокировки потребуется применение гибридного подхода документно-реляционной базы данных что позволит повысить гранулярность блокировок вплоть до отдельных полей (База -> Коллекция -> Файл -> Путь). Для примера можно представить приведённый выше документ в виде графа, представленного на рисунке 2.3.1.

![json_as_graph](../../media/json_graph.png)

Теперь каждый узел файла можно представить в виде отдельного неразделяемого ресурса. Такие ресурсы будут обозначатся как путь (Path, P). Он является уникальным описанием порядка ключей от корня документа до узла любого типа в виде последовательности. Такие указатели будут записыватся как индекс для ресурса в формате R_key1.key2...keyn. Например путь P={James, body parts, left arm} указывает на узел "R_James.body parts.left arm" содержащий скалярное значение "normal".

Однако для формирования гранулярных блокировок на более детальном уровне чем файлы требуется подход который применяется в менеджерах блокировок реляционных баз данных. Но такой подход требует наличия заведомо предопределённой структуры всех хранимых данных. Поэтому придётся применять подход извлечения схемы из файлов (Schema Inference).

### Schema Inference
В основе документно-ориентированного подхода лежит концепция полуструктурированных данных. В отличие от жестко типизированных кортежей реляционной модели, документ в формате JSON (JavaScript Object Notation) обладает свойством самоописания (self-describing). Математически это выражается через рекурсивное определение: объект O есть отображение множества ключей K на множество значений V, где V∈{S∪O∪A} (S — скаляры, A — массивы). При анализе подобного определения можно сформировать промежуточный абстрактный слой - схему (Schema, S). Поскольку в коллекции могут хранится файлы с разной внутреней структурой, то необходимо будет разработать алгоритм формирования схемы, который сможет выполнять следующие операции:
- Инспекция путей: При формировании или обновлении схемы​ система выполняет рекурсивный обход дерева ключей, формируя множество путей Pnew​={p1​,p2​,…,pn​}.
- Определение типов: Для каждого сформированного пути необходимо определять тип узла и тип данных для скалярных узлов.
- Слияние: Текущий прототип коллекции S_coll​ обновляется путем теоретико-множественного объединения с путями нового документа: S_coll ​= S_coll ​∪ P_new​. А так же выводить общие типы данных в узлах, где это возможно.

Задача преобразования неструктурированного JSON в формальный граф путей опирается на фундаментальные работы в области Schema Inference. В частности, подход к рекурсивному синтезу типов, предложенный в работах M.A. Baazizi, рассматривает схему как объединение (union) типов всех экземпляров документов в коллекции. В рамках данной диссертации этот подход адаптируется для задач управления конкурентным доступом.

В отличие от алгоритмов, используемых в аналитических системах (например, Apache Spark Schema Inference), где целью является формирование плоской реляционной структуры, наш метод ориентирован на сохранение иерархических связей. Это согласуется с теорией решеток типов (type lattices), где каждый новый документ расширяет границы текущего прототипа схемы до момента достижения стабилизации структуры.

Математическое исследование Schema Inference
Опиши алгоритм вывода схемы как математическую функцию.
- Вход: Множество документов D={d1​,d2​,...,dn​}.
- Выход: Граф схемы G=(V,E), где узлы — это пути к полям (например, user.address.city).
- Докажи сложность алгоритма: Покажи, что вывод схемы не занимает больше времени, чем сама транзакция (это критично для производительности).






### DLM
Научный вес: «Конфликт транзакций T1​ и T2​ возникает тогда и только тогда, когда Path(vT1​) ∩ Path(vT2) = ∅».

 Для обеспечения корректности взаимодействия различных уровней иерархии вводятся интенционные типы блокировок:
* **IS (Intent Shared)** — намерение прочитать данные на необходимых для выполнения запроса узлах;
* **S (Shared)** — активное чтение данных узла;
* **IX (Intent Exclusive)** — намерение модифицировать данные на запрашиваемых узлах;
* **X (Exclusive)** — активное изменение данных на запрашиваемых узлах.

Совместимость данных типов блокировок определяется классической матрицей совместимости, представленной в таблице 2.1.1, в которой "Да" обозначает что блокировки совместимы (транзакции могут работать параллельно), а "Нет" — конфликт (вторая транзакция должна ждать).

УЖЕ ЕСТЬ / ПРОСИТ|IS|IX|S|X
---|---|---|---|---
IS|Да|Да|Да|Нет
IX|Да|Да|Нет|Нет
S|Да|Нет|Да|Нет
X|Нет|Нет|Нет|Нет

Однако её применение в распределенной среде для динамически изменяющихся схем требует специализированного алгоритма.
### Распределённость
## 2.4 Формализация задачи через сети Петри (Начало)
## 2.7 Проведение «мысленного» или модельного эксперимента
## 2.8 Вывод


---

1. Baazizi, M. A. Schema inference for massive JSON datasets / M. A. Baazizi, H. Lahrouni, J. M. Mace // Proceedings of the 21st International Database Engineering & Applications Symposium. — ~~2017~~. — ~~P. 183–192~~. — DOI: ~~10.1145/3105831.3105845~~.

Frozza, A. A. An approach for schema extraction of JSON and NoSQL documents / A. A. Frozza, R. d. Mello, R. d. Costa // Proceedings of the 33rd Annual ACM Symposium on Applied Computing. — ~~2018. — P. 531–538. — DOI: 10.1145/3167132.3167193.~~
https://www.researchgate.net/publication/326380865_An_Approach_for_Schema_Extraction_of_JSON_and_Extended_JSON_Document_Collections

Klettke, M. Schema extraction and structural outlier detection for JSON-based NoSQL data stores / M. Klettke, U. Störl, S. Scherzinger // 31st IEEE International Conference on Data Engineering. — ~~2015. — P. 425–436. — DOI: 10.1109/ICDE.2015.7113304.~~

Пирс, Б. Типы в языках программирования / Б. Пирс ; пер. с англ. Г. Бронникова, А. Коновалова. — Москва : Добросвет, ~~2012. — 680 с. — ISBN 978-5-7913-0082-9.~~

Hoare, C. A. R. Communicating Sequential Processes / ~~C. A. R. Hoare. — Prentice Hall International, 1985. — 256 p. — ISBN 0-13-153271-5.~~

Gray, J. Transaction Processing: Concepts and Techniques / J. Gray, A. Reuter. — Morgan Kaufmann Publishers, ~~1992. — 1070 p. — ISBN 1-55860-190-2~~. (Классический источник по иерархическим блокировкам — MGL).

Baader, F. The Description Logic Handbook: Theory, Implementation, and Applications / F. Baader, D. Calvanese [et al.]. — Cambridge University Press, ~~2003. — 602 p. — ISBN 0-521-78176-0.~~ (Полезно для формализации вложенных структур).