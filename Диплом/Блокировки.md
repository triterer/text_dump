Блокировки
========================

## Виды блокировок
### Блокировка поддерева индексов
Поскольку все столбцы id в таблицах ссылок на документы проиндексированны в формате бинарных деревьев существует возможность блокировать поддерево для эффективной блокировки. При блокировке в дереве соответсующий узел помечается как заблокированный. Любые поиски пытающиеся провести поиск этого узла или глубже ожидают его разблокировки.


### Блокировка чтения строки
При чтении в таблице у троки инкрементируется значение чтения в таблице. При окончании декрементируется

### Блокировка записи строки
Перед записью строка в таблице помечается как готовящаяся к записи в таблице. В этом состоянии клиент ждёт обнуления числа чтений. Добавление новых чтений в этом состоянии невозможно.

Когда все чтения завершены, строка блокируется для записи. По окончанию изменений разблокируется.

### Блокировка таблицы
При изменениях затрагивающих всю таблицу она помечается как готовящаяся к записи. В этом состоянии клиент ждёт обнуления числа чтений и записей строк. Добавление новых чтений и заисей строк в этом состоянии невозможно.

Когда все операции над строками завершены, таблица блокируется и операция над ней производится. После этого таблица разблокируется.




## Заблокированное состояние при использовании блокировок
### В пределах сервера
#### Ошибка на клиенте во время редактирования записи
1. Клиент читает файл с сервера с целью изменения и блокирует его для изменений
2. Клиент полчает ошибку при во время записи, без возможности восстановления

Файл остаётся в заблокированном состоянии без возможности восстановления.

Схема работы:

![petri_db_write_failure](../media/petri_db-%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D1%8C%20%D1%84%D0%B0%D0%B9%D0%BB%D0%B0.png)

Порядок исполнения:
```
Клиент -> Получение метаданных таблицы -> Получение метаданных файла -> μ Ожидание • Проверить статус блокировки ->
    ( Ожидание
    | Заблокировать файл -> Записать файл -> Разблокировать Файл -> Клиент )
```
Порядок исполнения с возникновением ошибки:
```
Клиент -> Получение метаданных таблицы -> Получение метаданных файла -> μ Ожидание • Проверить статус блокировки ->
    ( Ожидание
    | Заблокировать файл -> СТОП
    | Заблокировать файл -> Записать файл -> Разблокировать Файл -> Клиент )
```

Псевдо sql:
```sql
UPDATE `Таблица` SET c1=c1+1 WHERE id=1;
```

#### Изменения двух клиентов
##### Пример 1
Первый клиент должен добавить имя работника к описанию его должности. Второй должен добавить каждому работнику название отдела в личные данные.

1. Первый клиент читает персональные работника и блокирует их.
2. Второй клиент читает должность работника и блокирует ее.
3. Первый клиент пытвается прочитать должность работника, но не может, так как она заблокированнна.
4. Второй клиент пытается прочитать персональные данные, но не может, так как они заблокированнна.

Оба клиента захватили часть данных и ожидают изменения друг у друга. Они заблокированны.

Состояние БД до изменений:

![petri_db_two_writes_schema](../media/petri_db-%D0%94%D0%B2%D0%B5%20%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B8%20%D1%81%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_two_writes_block](../media/petri_db-%D0%94%D0%B2%D0%B5%20%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B8.png)

Порядок исполнения:
```
1.Клиент -> Получение метаданных таблицы Worker -> Получение метаданных файла worker/1111 -> μ Ожидание • Проверить статус блокировки файла worker/1111 ->
    ( Ожидание
    | Заблокировать файл worker/1111 -> Изменить файл worker/1111 -> Получить метаданные таблицы job -> Получить метаданные файла job/2111 -> μ Ожидание • Проверить статус блокировки файла job/2111 ->
        ( Ожидание
        | Заблокировать файл job/2111 -> Изменить файл job/2111 -> Разблокировать файл worker/1111 -> Разблокировать файл job/2111 -> 1.Клиент )
```
Псевдо sql:
```sql
UPDATE `Worker`
SET fk_job = 2112
WHERE id = 1111;
```
```
2.Клиент -> Получение метаданных таблицы Job -> Получение метаданных файла job/2111 -> μ Ожидание • Проверить статус блокировки файла job/2111 ->
    ( Ожидание
    | Заблокировать файл job/2111 -> Изменить файл job/2111 -> Получить метаданные таблицы worker -> Получить метаданные файла worker/1111 -> μ Ожидание • Проверить статус блокировки файла worker/1111 ->
        ( Ожидание
        | Заблокировать файл worker/1111 -> Изменить файл worker/1111 -> Разблокировать файл job/2111 -> Разблокировать файл worker/1111 -> 2.Клиент )
```
Псевдо sql:
```sql
UPDATE `JOB`
SET fk_worker = 1112
WHERE id = 2111;
```

##### Пример 2

Первый клиент пытается перенести компьютер из отдела 1 в отдел 2. А второй наоборот из отдела 2 в отдел 1.

1. Первый клиент получает ссылку из отдела 1 на компьютеры связаные с этим отделом.
2. Первый клиент блокирует строку компьютеров в первом отделе и читает оттуда данные.
3. Второй клиент получает ссылку из отдела 2 на компьютеры связаные с этим отделом.
4. Второй клиент блокирует строку компьютеров во втором отделе и читает данные оттуда.
5. Первый клиент получает ссылку на компьютеры отдела 2.
6. Первый клиент не может заблокировать для чтения и изменения строку с компьютерами для отдела 2, так как она заблокированы вторым клиентом.
7. Второй клиент получает ссылку на компьютеры из отдела 1.
8. Второй клиент не может заблокировать для чтения и изменения строку с компьютерами для отдела 1, так как она заблокированна первым клиентом.

Оба клиента не могут закончить работу, так как оба захватили только часть необходимых разделяемы ресурсов.

Состояние БД до изменений:

![petri_db_concurent_operations_schema](../media/petri_db-%D0%9A%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0-3.png)



Схема работы:

![petri_db_concurent_operations](../media/petri_db-%D0%9A%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8.png)


```
1.Клиент -> Получение метаданных таблицы department -> μ Ожидание • Проверить блокировку строки department/4111 ->
    ( Ожидание
    | Прочитать строку department/4111 -> Получить метаданные таблицы computer -> μ Ожидание • Проверить блокировку строки computer/5111 ->
        ( Ожидание
        | Заблокировать строку computer/5111 -> Прочитать файл computer/5111 ->  μ Ожидание • Проверить блокировку строки department/4112 ->
            ( Ожидание
            | Прочитатать строку department/4112 -> μ Ожидание • Проверить блокировку строки computer/5112 ->
                ( Ожидание
                | Заблокировать строку computer/5112 -> Прочитать файл computer/5112 -> Изменить файл computer/5111 -> изменить файл computer/5112 -> Разблокировать файл computer/5111 -> Разблокировать файл computer/5112)))) ->  1.Клиент
```
Псевдо sql:
```sql
UPDATE `Computer`
SET quantity = quantity + 1
WHERE fk_department = (select id from department where name = "Отдел 1");

UPDATE `Computer`
SET quantity = quantity - 1
WHERE fk_department = (select id from department where name = "Отдел 2");
```

```
2.Клиент -> Получение метаданных таблицы department -> μ Ожидание • Проверить блокировку строки department/4112 ->
    ( Ожидание
    | Прочитать строку department/4112 -> Получить метаданные таблицы computer -> μ Ожидание • Проверить блокировку строки computer/5112 ->
        ( Ожидание
        | Заблокировать строку computer/5112 -> Прочитать файл computer/5112 ->  μ Ожидание • Проверить блокировку строки department/4111 ->
            ( Ожидание
            | Прочитатать строку department/4111 -> μ Ожидание • Проверить блокировку строки computer/5111 ->
                ( Ожидание
                | Заблокировать строку computer/5111 -> Прочитать файл computer/5111 -> Изменить файл computer/5112 -> изменить файл computer/5111 -> Разблокировать файл computer/5112 -> Разблокировать файл computer/5111)))) ->  1.Клиент
```

Псевдо sql:
```sql
UPDATE `Computer`
SET quantity = quantity + 1
WHERE fk_department = (select id from department where name = "Отдел 2");

UPDATE `Computer`
SET quantity = quantity - 1
WHERE fk_department = (select id from department where name = "Отдел 1");
```

#### Изменения ссылок
Первый клиент пытается перевести сотрудника в новый отдел. Второй пытается удалить отдел с удалением всех сотрудников в нём состоявших, для поддержания целостности

1. Первый клиент читает файл должности и блокирует его.
2. Второй клиент удаляет строку с отделом.
3. Второй клиент пытается изменить строку должности сотрудника, но не может. Так как она заблокированна.
4. Первый клиент пытается прочитать таблицу отделов с целью проверки корректности получаемой ссылки, но не может, так как она заблокированна.

В результате оба клиента заблокированны.

Схема БД до изменений:

![petri_db_change_links_schema](../media/petri_db-%D0%A1%D0%BC%D0%B5%D0%BD%D0%B0%20%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA%20%D1%81%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_link_change](../media/petri_db-%D0%A1%D0%BC%D0%B5%D0%BD%D0%B0%20%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA-1.png)


```
1.Клиент -> Получение метаданных таблицы worker -> Получение ссылки на таблицу job -> μ Ожидание • Проверить блокировку строки job/2111 ->
    ( Ожидание
    | Заблокировать строку job/2111 -> Получить метаданные файлов department -> μ Ожидание • Проверить блокировку файла(department/X) ->
        (Ожидание
        | Прочитать файл(department/X) -> Ожидание) -> Изменить строку job/2111 -> Разблокировать строку job/2111)) -> 1.Клиент
```
Псевдо sql:
```sql
UPDATE `Job`
SET fk_department = (select id from department where id = 4112)
WHERE fk_worker = (select id from worker where id = 1111);
```

```
2.Клиент -> Получение метаданных таблицы department -> μ Ожидание • Проверить блокировку строки department/4111 ->
    ( Ожидание
    | Заблокировать строку department/4111 -> Удалить файл department/4111 -> Получить метаданные таблицы job -> μ Ожидание • Проверить блокировку строки (job/X) ->
        ( Ожидание
        | Заблокировать строку (job/X) -> Изменить строку (Job/X)) -> μ Разблокировать строку (job/X) -> разблокировать строку department/4111)) -> 2.Клиент
```
Псевдо sql:
```sql
DELETE FROM department WHERE id = 4111;
```


#### Удаление прав доступа к таблице
Первый клиент обновляет строки в таблице Department, потом в Employee. Второй клиент снимает с первого права на доступ к таблицам Department и Employee.
1. Первый клиент блокирует файл 4111 в таблице Department
2. Первый клиент изменяет файл 4111 в таблице Department
3. Второй клиент изменяет права доступа к таблице Employee и Department, запрещая первому клиенту доступ к ним
4. Первый клиент пытается заблокировать строку 2111 в таблице Employee, но не может, так как у него нет прав на доступ к этой таблице.

Первый клиент не может заблокировать строку 2111 в таблице Employee, в следствии этого он не может завершить транзакцию и остаётся в заблокированном состоянии.

Состояние БД:

![petri_db_access_revoke_schema](../media/petri_db-%D0%9E%D1%82%D0%B7%D1%8B%D0%B2%20%D0%BF%D1%80%D0%B0%D0%B2%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_access_revoke](../media/petri_db-%D0%9E%D1%82%D0%B7%D1%8B%D0%B2%20%D0%BF%D1%80%D0%B0%D0%B2.png)

```
1.Клиент -> Получение метаданных таблицы Department -> Получение метаданных файла department/4111 -> μ Ожидание • Проверить блокировку строки department/4111 ->
    ( Ожидание
    | Заблокировать файл department/4111 -> Изменить файл department/4111 -> Получение метаданных таблицы worker -> получение метаданных файла worker/2111 -> μ Ожидание • Проверить блокировку файла worker/2111 ->
        (Ожидание
        | Заблокировать файл worker/2111 -> Изменить строку worker/2111 -> Разблокировать строку worker/2111 -> Разблокировать строку department/4111)) -> 1.Клиент
```
Псевдо sql:
```sql
BEGIN TRANSACTION;

UPDATE `Department`
SET id = 4112
WHERE id = 4111;
```

```
1.Клиент -> Изменить права доступа клиента 1 -> 1.Клиент
```




#### Блокировка диапазона индексов
Поскольку


### Между кластерами
#### Синхронизация изменений
Блокировка изменений кластера происходит только в пределах одного кластера.
1. Первый клиент блокирует файл 1111 в таблице table а первом кластере
2. Втором клиент блокирует файл 1111 в таблице table а втором кластере
3. Первый клиент изменяет файл 1111 в таблице table на первом кластере
4. Второй клиент изменяет файл 1111 в таблице table на втором кластере
5. Первый клиент получает список серверов, содержащих таблицу table
6. Второй клиент получает список серверов, содержащих таблицу table
7. Первый клиент пытается заблокировать файл 1111 в таблице table на втором кластере для репликации своих изменений, но не может этого сделать, так как строка заблокированна клиентом 2
8. Второй клиент пытается заблокировать файл 1111 в таблице table на первом кластере для репликации своих изменений, но не может этого сделать, так как строка заблокированна клиентом 1

Клиент 1 ожидает разблокировки файла на кластере 2, в то время как клиент 2 ожидает разблокировки файла на первом кластере. Оба клиента не могут продолжать работу.

Состояния БД:

![petri_db_replication_schema](../media/petri_db-%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_replication](../media/petri_db-%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F.png)

```
1.Клиент -> Получение метаданных таблицы 1.table -> Получение метаданных файла 1.table/1111 -> μ Ожидание • Проверить блокировку строки 1.table/1111 ->
    ( Ожидание
    | Заблокировать файл 2.table/1111 -> Изменить файл 1.table/1111 -> 1.Получение адресов серверов, содержащих таблицу table -> Получение метаданных таблицы 2.table -> Получение метаданных файла 2.table/1111 -> μ Ожидание • Проверить блокировку файла 2.table/1111 ->
        (Ожидание
        | Заблокировать файл 2.table/1111 -> Изменить строку 2.table/1111 -> Разблокировать строку 2.table/1111 -> Разблокировать строку 1.table/1111)) -> 1.Клиент
```
Псевдо sql:
```sql
UPDATE `table`
SET vale = 2
WHERE id = 1;
```

```
2.Клиент -> Получение метаданных таблицы 2.table -> Получение метаданных файла 2.table/1111 -> μ Ожидание • Проверить блокировку строки 1.table/1111 ->
    ( Ожидание
    | Заблокировать файл 2.table/1111 -> Изменить файл 2.table/1111 -> 2.Получение адресов серверов, содержащих таблицу table -> Получение метаданных таблицы 1.table -> Получение метаданных файла 1.table/1111 -> μ Ожидание • Проверить блокировку файла 1.table/1111 ->
        (Ожидание
        | Заблокировать файл 1.table/1111 -> Изменить строку 1.table/1111 -> Разблокировать строку 1.table/1111 -> Разблокировать строку 2.table/1111)) -> 2.Клиент
```
Псевдо sql:
```sql
UPDATE `table`
SET vale = 1000
WHERE id = 1;
```

## Возможные условия блокировок, сводящиеся к тем что описаны
1. Цикличная блокировка трёх клиентов с захватом каждого одного из трёх разделяемых ресуров - сводится к задаче с блокировкой двух клиентов с двумя ресурсами.
2. Блокировка в пересекающихся диапазонах - диапазоны реализованы только в формати блокировки поддерева индексов. Блокировка диапазона индексов описана в соответсвующем примере.
3. Блокировка через эскалацию блокировки от части строк до всей таблицы на двух клиентах - сводится к блокировке двух клиентов с двумя ресурсам. Если всего разделяемых ресурса два, то захват одного потом второго эквиваленте захвату одного потом всей таблицы
4. Блокировка в связи с медленной репликацией данных между серверами - сводится к блоировкой со взаимной репликацией, так как кейс описан событийно без привязки к длительноти процессов.
5. Взаимоисключающие операции над одним и тем же значении (инкрементирование и одновременное декрементироваие ресурса) - Задача сводится к задачам с n клиентов и n операций. Если есть хоть два разделяемых ресурса, то при захвате обоих разными клиентами процессы будут заблокированны. Если ресурс один, то он будет доступен процессам ожидающим его, после окончания работы процесса что его захватил.
6. Удаление таблицы одним клиентом перед захватом строки в ней другим - совпадает с примером изменения прав доступа, так как в обоих случаях у клиента полностью пропадает доступ к одному из требуемых разделяемых реурсов.