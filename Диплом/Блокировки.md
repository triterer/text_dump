Блокировки
========================

## Виды блокировок
### Блокировка поддерева индексов
Поскольку все столбцы id в таблицах ссылок на документы проиндексированны в формате бинарных деревьев существует возможность блокировать поддерево для эффективной блокировки. При блокировке в дереве соответсующий узел помечается как заблокированный. Любые поиски пытающиеся провести поиск этого узла или глубже ожидают его разблокировки.


### Блокировка чтения строки
При чтении в таблице у троки инкрементируется значение чтения в таблице. При окончании декрементируется

### Блокировка записи строки
Перед записью строка в таблице помечается как готовящаяся к записи в таблице. В этом состоянии клиент ждёт обнуления числа чтений. Добавление новых чтений в этом состоянии невозможно.

Когда все чтения завершены, строка блокируется для записи. По окончанию изменений разблокируется.

### Блокировка таблицы
При изменениях затрагивающих всю таблицу она помечается как готовящаяся к записи. В этом состоянии клиент ждёт обнуления числа чтений и записей строк. Добавление новых чтений и заисей строк в этом состоянии невозможно.

Когда все операции над строками завершены, таблица блокируется и операция над ней производится. После этого таблица разблокируется.




## Заблокированное состояние при использовании блокировок
### В пределах сервера
#### Ошибка на клиенте во время редактирования записи
1. Клиент получает метаданные таблицы от базы метаданных таблиц
2. Клиент помечает в базе данных таблицы файл как заблокированный для изменений
3. Клиент получает метаданные файла который собирается изменить от базы данных данной таблицы
4. Клиент измет файл
5. Ошибка на клиенте не даёт ему возможности завершить процесс

Файл остаётся в заблокированном состоянии. Другие клиенты, которые будут пытаться получить доступ к файлу будут ждать его разблокировки, которая никогда не наступит

Схема работы:

![petri_db_write_failure](../media/petri_db-%D0%97%D0%B0%D0%BF%D0%B8%D1%81%D1%8C%20%D1%84%D0%B0%D0%B9%D0%BB%D0%B0.png)

Порядок исполнения:
```
Клиент -> Получение метаданных таблицы -> Получение метаданных файла -> μ Ожидание • Проверить статус блокировки ->
    ( Ожидание
    | Заблокировать файл -> Записать файл -> Разблокировать Файл -> Клиент )
```
Порядок исполнения с возникновением ошибки:
```
Клиент -> Получение метаданных таблицы ->  μ Ожидание • Проверить статус блокировки ->
    ( Ожидание
    | Заблокировать файл -> СТОП
    | Заблокировать файл -> Получение метаданных файла -> Записать файл -> Разблокировать Файл -> Клиент )
```

Псевдо sql:
```sql
UPDATE `Таблица` SET c1=c1+1 WHERE id=1;
```

#### Изменения двух клиентов
##### Пример 1
Первый клиент должен добавить имя работника к описанию его должности. Второй должен добавить каждому работнику название отдела в личные данные.

1. Первый клиент получает метаданные таблицы Worker от базы метаданных таблиц
2. Первый клиент проверяет блокировку файла worker/1111
3. Первый клиент блокирует файл worker/1111 в базе таблице Worker
4. Первый клиент получает метаданные файла worker/1111 от таблицы метаданных worker
5. Первый клиент изменяет файл worker/1111

6.  Второй клиент получает метаданные таблицы Job от базы метаданных таблиц
7. Второй клиент проверяет блокировку файла job/2111
8. Второй клиент блокирует файл job/2111 в базе таблице Job
9. Второй клиент получает метаданные файла job/2111 от таблицы метаданных job
10. Второй клиент изменяет файл job/2111

11. Первый клиент получает метаданные таблицы Job от базы метаданных таблиц
12. Первый клиент проверяет блокировку файла job/2111, файл заблокирован вторым клиентом. Первый клиент ждёт разблокировки файла

13. Второй клиент получает метаданные таблицы Worker от базы метаданных таблиц
14. Второй клиент проверяет блокировку файла worker/1111, файл заблокирован первым клиентом. Второй клиент ждёт разблокировки файла

Оба клиента захватили часть данных и ожидают изменения друг у друга. Они заблокированны.

Состояние БД до изменений:

![petri_db_two_writes_schema](../media/petri_db-%D0%94%D0%B2%D0%B5%20%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B8%20%D1%81%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_two_writes_block](../media/petri_db-%D0%94%D0%B2%D0%B5%20%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B8.png)

Порядок исполнения:
```
1.Клиент -> Получение метаданных таблицы Worker ->  μ Ожидание • Проверить статус блокировки файла worker/1111 ->
    ( Ожидание
    | Заблокировать файл worker/1111 -> Получение метаданных файла worker/1111 -> Изменить файл worker/1111 -> Получить метаданные таблицы job ->  μ Ожидание • Проверить статус блокировки файла job/2111 ->
        ( Ожидание
        | Заблокировать файл job/2111 -> Получить метаданные файла job/2111 -> Изменить файл job/2111 -> Разблокировать файл worker/1111 -> Разблокировать файл job/2111 -> 1.Клиент )
```
Псевдо sql:
```sql
UPDATE `Worker`
SET fk_job = 2112
WHERE id = 1111;
```
```
2.Клиент -> Получение метаданных таблицы Job ->  μ Ожидание • Проверить статус блокировки файла job/2111 ->
    ( Ожидание
    | Заблокировать файл job/2111 -> Получение метаданных файла job/2111 -> Изменить файл job/2111 -> Получить метаданные таблицы worker ->  μ Ожидание • Проверить статус блокировки файла worker/1111 ->
        ( Ожидание
        | Заблокировать файл worker/1111 -> Получить метаданные файла worker/1111 -> Изменить файл worker/1111 -> Разблокировать файл job/2111 -> Разблокировать файл worker/1111 -> 2.Клиент )
```
Псевдо sql:
```sql
UPDATE `JOB`
SET fk_worker = 1112
WHERE id = 2111;
```

##### Пример 2
TODO:  Упростить этот пример. Здесь достаточно одной таблицы, так как разделяемым ресурсом являются строки

Первый клиент пытается перенести компьютер из отдела 1 в отдел 2. А второй наоборот из отдела 2 в отдел 1.

1. Первый клиент получает метаданные таблицы Department от базы метаданных таблиц
2. Первый клиент проверяет блокировку файла departmen/4111
3. Первый клиент блокирует файл departmen/4111 в базе таблице Department для чтения
4. Первый клиент получает метаданные файла department/4111 от таблицы метаданных department
5. Первый клиент изменяет файл departmen/4111

6. Второй клиент получает метаданные таблицы Department от базы метаданных таблиц
7. Второй клиент проверяет блокировку файла departmen/4112
8. Второй клиент блокирует файл departmen/4112 в базе таблице Department для чтения
9. Второй клиент получает метаданные файла department/4112 от таблицы метаданных department
10. Второй клиент изменяет файл departmen/4112

11. Первый клиент получает метаданные таблицы Computer от базы метаданных таблиц
12. Первый клиент проверяет блокировку файла computer/5111
13. Первый клиент блокирует файл computer/5111 в базе таблице Computer для записи
14. Первый клиент получает метаданные файла computer/5111 от таблицы метаданных computer
15. Первый клиент изменяет файл computer/5111
16. Первый клиент получает метаданные файла computer/5111  от таблицы метаданных department

17. Второй клиент получает метаданные таблицы Computer от базы метаданных таблиц
18. Второй клиент проверяет блокировку файла computer/5112
19. Второй клиент блокирует файл computer/5112 в базе таблице Computer для записи
20. Второй клиент получает метаданные файла computer/5112 от таблицы метаданных computer
21. Второй клиент изменяет файл computer/5112
22. Второй клиент получает метаданные файла computer/5112  от таблицы метаданных department

23. Первый клиент проверяет блокировку файла departmen/4112
24. Первый клиент блокирует файл departmen/4112 в базе таблице Worker для чтения
25. Первый клиент получает метаданные файла department/4112 от таблицы метаданных department
26. Первый клиент изменяет файл departmen/4112

27. Второй клиент проверяет блокировку файла departmen/4111
28. Второй клиент блокирует файл departmen/4111 в базе таблице Department для чтения
29. Второй клиент получает метаданные файла department/4111 от таблицы метаданных department
30. Второй клиент изменяет файл departmen/4111

31. Первый клиент получает метаданные таблицы Computer от базы метаданных таблиц
32. Первый клиент проверяет блокировку файла computer/5112. Файл заблокирован, поэтому первый клиент ожидает разблокировки

33. Второй клиент получает метаданные таблицы Computer от базы метаданных таблиц
34. Второй клиент проверяет блокировку файла computer/5111. Файл заблокирован, поэтому второй клиент ожиддает разблокировки

Оба клиента не могут закончить работу, так как оба захватили только часть необходимых разделяемы ресурсов.

Состояние БД до изменений:

![petri_db_concurent_operations_schema](../media/petri_db-%D0%9A%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0-3.png)



Схема работы:

![petri_db_concurent_operations](../media/petri_db-%D0%9A%D0%BE%D0%BD%D0%BA%D1%83%D1%80%D0%B8%D1%80%D1%83%D1%8E%D1%89%D0%B8%D0%B5%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B8.png)


```
1.Клиент -> Получение метаданных таблицы department -> μ Ожидание • Проверить блокировку строки department/4111 ->
    ( Ожидание
    | Получить метаданные файла department/4111 -> Прочитать строку department/4111 -> Получить метаданные таблицы computer ->  μ Ожидание • Проверить блокировку строки computer/5111 ->
        ( Ожидание
        | Заблокировать строку computer/5111 -> Получить метаданные файла computer/51112 -> Прочитать файл computer/5111 ->  μ Ожидание • Проверить блокировку строки department/4112 ->
            ( Ожидание
            | Получить метаданные файла department/4112 -> Прочитатать строку department/4112 -> μ Ожидание • Проверить блокировку строки computer/5112 ->
                ( Ожидание
                | Заблокировать строку computer/5112 -> Получить метаданные файла computer/5112 -> Прочитать файл computer/5112 -> Изменить файл computer/5111 -> изменить файл computer/5112 -> Разблокировать файл computer/5111 -> Разблокировать файл computer/5112)))) ->  1.Клиент
```
Псевдо sql:
```sql
UPDATE `Computer`
SET quantity = quantity + 1
WHERE fk_department = (select id from department where name = "Отдел 1");

UPDATE `Computer`
SET quantity = quantity - 1
WHERE fk_department = (select id from department where name = "Отдел 2");
```

```
2.Клиент -> Получение метаданных таблицы department -> μ Ожидание • Проверить блокировку строки department/4112 ->
    ( Ожидание
    | Получить метаданные файла department/4112 -> Прочитать строку department/4112 -> Получить метаданные таблицы computer -> μ Ожидание • Проверить блокировку строки computer/5112 ->
        ( Ожидание
        | Заблокировать строку computer/5112 -> Получить метаданные файла computer/5112 -> Прочитать файл computer/5112 ->  μ Ожидание • Проверить блокировку строки department/4111 ->
            ( Ожидание
            | Получить метаданные файла department/4111 -> Прочитатать строку department/4111 -> μ Ожидание • Проверить блокировку строки computer/5111 ->
                ( Ожидание
                | Заблокировать строку computer/5111 -> Получить метаданные файла computer/5111 -> Прочитать файл computer/5111 -> Изменить файл computer/5112 -> изменить файл computer/5111 -> Разблокировать файл computer/5112 -> Разблокировать файл computer/5111)))) ->  1.Клиент
```

Псевдо sql:
```sql
UPDATE `Computer`
SET quantity = quantity + 1
WHERE fk_department = (select id from department where name = "Отдел 2");

UPDATE `Computer`
SET quantity = quantity - 1
WHERE fk_department = (select id from department where name = "Отдел 1");
```

#### Изменения ссылок
Первый клиент пытается перевести сотрудника в новый отдел. Второй пытается удалить отдел с удалением всех сотрудников в нём состоявших, для поддержания целостности

1. Первый клиент получает метаданные таблицы Worker
2. Первый клиент читает сслыку на таблицу Job из таблицы worker, строка 1111

1. Первый клиент получает метаданные таблицы Job от базы метаданных таблиц
2. Первый клиент проверяет блокировку файла job/2111
3. Первый клиент блокирует файл job/2111 в базе таблице Job для записи
4. Первый клиент получает метаданные файла job/2111 от таблицы метаданных Job

5. Второй клиент получает метаданные таблицы Department
6. Второй клиент проверяет блокировку таблицы Department
7. Второй клиент блокирует строку department/4111
8. Второй клиент файл department/4111

9. Первый клиент проверяет блокировку файла department/4111 и переходит в ожидание, так как файл заблокирован вторым клиентом
10. Второй клиент удаляет строку department/4111

11. Второй клиент получает метаданные таблицы Job
12. Второй клиент получает сканирует таблицу Job для нахождения строк со ссылкой на department/4111
13. Второй клиент проверяет блокировку файла Job/2111. Файл заблокирован первым клиентом, поэтому второй клиент ожидает разблокировки

Оба клиента ожидают взаимной разблокировки требуемых ресурсов. Они заблокированны

Схема БД до изменений:

![petri_db_change_links_schema](../media/petri_db-%D0%A1%D0%BC%D0%B5%D0%BD%D0%B0%20%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA%20%D1%81%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_link_change](../media/petri_db-%D0%A1%D0%BC%D0%B5%D0%BD%D0%B0%20%D1%81%D1%81%D1%8B%D0%BB%D0%BE%D0%BA-1.png)


```
1.Клиент -> Получение метаданных таблицы worker -> Получение ссылки на таблицу job -> μ Ожидание • Проверить блокировку строки job/2111 ->
    ( Ожидание
    | Заблокировать строку job/2111 -> Получить метаданные файла job/2111 -> Получить метаданные файлов department -> μ Ожидание • Проверить блокировку файла(department/X) ->
        (Ожидание
        | Получить метаданные файла (department/X) -> Прочитать файл(department/X) -> Ожидание) -> Изменить строку job/2111 -> Разблокировать строку job/2111)) -> 1.Клиент
```
Псевдо sql:
```sql
UPDATE `Job`
SET fk_department = (select id from department where id = 4112)
WHERE fk_worker = (select id from worker where id = 1111);
```

```
2.Клиент -> Получение метаданных таблицы department -> μ Ожидание • Проверить блокировку строки department/4111 ->
    ( Ожидание
    | Заблокировать строку department/4111 -> Получить метаданные файла department/4111 -> Удалить файл department/4111 -> Получить метаданные таблицы job -> Получить список строк со ссылкой на department/4111 -> μ Ожидание • Проверить блокировку строки (job/X) ->
        ( Ожидание
        | Заблокировать строку (job/X) -> Получить метаданные файла (Job/X)) -> Изменить строку (Job/X)) -> μ • Разблокировать строку (job/X) -> разблокировать строку department/4111)) -> 2.Клиент
```
Псевдо sql:
```sql
DELETE FROM department WHERE id = 4111;
```


#### Удаление прав доступа к таблице
Первый клиент обновляет строки в таблице Department, потом в Employee. Второй клиент снимает с первого права на доступ к таблицам Department и Employee.
1. Первый клиент блокирует файл 4111 в таблице Department
2. Первый клиент изменяет файл 4111 в таблице Department
3. Второй клиент изменяет права доступа к таблице Employee и Department, запрещая первому клиенту доступ к ним
4. Первый клиент пытается заблокировать строку 2111 в таблице Employee, но не может, так как у него нет прав на доступ к этой таблице.

Первый клиент не может заблокировать строку 2111 в таблице Employee, в следствии этого он не может завершить транзакцию и остаётся в заблокированном состоянии.

Состояние БД:

![petri_db_access_revoke_schema](../media/petri_db-%D0%9E%D1%82%D0%B7%D1%8B%D0%B2%20%D0%BF%D1%80%D0%B0%D0%B2%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_access_revoke](../media/petri_db-%D0%9E%D1%82%D0%B7%D1%8B%D0%B2%20%D0%BF%D1%80%D0%B0%D0%B2.png)

```
1.Клиент -> Получение метаданных таблицы Department -> μ Ожидание • Проверить блокировку строки department/4111 ->
    ( Ожидание
    | Заблокировать файл department/4111 -> Получение метаданных файла department/4111 -> Изменить файл department/4111 -> Получение метаданных таблицы worker -> μ Ожидание • Проверить блокировку файла worker/2111 ->
        (Ожидание
        | Заблокировать файл worker/2111 -> получение метаданных файла worker/2111 -> Изменить строку worker/2111 -> Разблокировать строку worker/2111 -> Разблокировать строку department/4111)) -> 1.Клиент
```
Псевдо sql:
```sql
BEGIN TRANSACTION;

UPDATE `Department`
SET id = 4112
WHERE id = 4111;
```

```
2.Клиент -> Изменить права доступа клиента 1 -> 2.Клиент
```




#### Блокировка диапазона индексов
Первый клиент блокирует изменяет файлы table/5 и table/15. Второй клиент изменяет файлы table/5, table/10, table/15. Для оптимизации блокировок клиент 2 блокирует узел 10.

1. Первый клиент блокирует файл 5 в таблице Table и изменяет его
2. Второй клиент блокирует узел 10 в индексном дереве
3. Второй клиент пытается изменить файл 5, но не может сделать этого, так как файл 5 заблокирован клиентом 1
4. Первый клиент пытается заблокировать для изменения файл 15, но не может этого сделать, так как один из его родительских узлов заблокирован

Клиент 1 ожидает разблокировки узла 10, занятый клиентом 2. В то  время как клиент 2 ожидает разблокировки файла 5, который занят клиентом 1. Оба клиента ожидают взаимной разблокировки.

Состояние БД:

![petri_db_index_blocking](../media/petri_db-%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_index_blocking](../media/petri_db-%D0%91%D0%BB%D0%BE%D0%BA%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D0%B8%D0%BD%D0%B4%D0%B5%D0%BA%D1%81%D0%BE%D0%B2.png)

```
1.Клиент -> Получение метаданных таблицы Table -> μ Ожидание • Получение метаданных файла table/5 ->
    ( Ожидание
    | μ Ожидание • Проверить блокировку строки table/5 ->
        ( Ожидание
        | Заблокировать файл table/5 -> Получить метаданные файла table/5 -> Изменить файл table/5 -> μ Ожидание • получение метаданных файла table/15 ->
            ( Ожидание
            | μ Ожидание • Проверить блокировку файла table/15 ->
                (Ожидание
                | Заблокировать файл table/15 -> Получить метаданные файла table/15 -> Изменить строку table/15 -> Разблокировать строку table/5 -> Разблокировать строку table/15)))) -> 1.Клиент
```
Псевдо sql:
```sql
BEGIN TRANSACTION;

UPDATE `TABLE`
SET name = "d"
WHERE id = 5;
UPDATE `TABLE`
SET name = "d"
WHERE id = 15;
```

```
2.Клиент -> Получение метаданных таблицы Table -> Блокировка узла table/10 -> Получение метаданных файла table/10 -> μ Ожидание • Проверить блокировку строки table/10 ->
    ( Ожидание
    | Получить метаданные файла table/10 -> Изменить файл table/10 -> μ Ожидание • Проверить блокировку файла table/5 ->
        (Ожидание
        | Получить метаданные файла table/5 -> Изменить строку table/5 -> μ Ожидание • Проверить блокировку файла table/15 ->
            (Ожидание
            | Получить метаданные файла table/15 -> Изменить строку table/15 -> Разблокировка узла table/10)))) -> 1.Клиент
```
Псевдо sql:
```sql
BEGIN TRANSACTION;

UPDATE `TABLE`
SET name = "k"
WHERE id in (5, 10, 15);
```


### Между кластерами
#### Синхронизация изменений
Блокировка изменений кластера происходит только в пределах одного кластера.
1. Первый клиент блокирует файл 1111 в таблице table а первом кластере
2. Втором клиент блокирует файл 1111 в таблице table а втором кластере
3. Первый клиент изменяет файл 1111 в таблице table на первом кластере
4. Второй клиент изменяет файл 1111 в таблице table на втором кластере
5. Первый клиент получает список серверов, содержащих таблицу table
6. Второй клиент получает список серверов, содержащих таблицу table
7. Первый клиент пытается заблокировать файл 1111 в таблице table на втором кластере для репликации своих изменений, но не может этого сделать, так как строка заблокированна клиентом 2
8. Второй клиент пытается заблокировать файл 1111 в таблице table на первом кластере для репликации своих изменений, но не может этого сделать, так как строка заблокированна клиентом 1

Клиент 1 ожидает разблокировки файла на кластере 2, в то время как клиент 2 ожидает разблокировки файла на первом кластере. Оба клиента не могут продолжать работу.

Состояния БД:

![petri_db_replication_schema](../media/petri_db-%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F%20%D0%A1%D1%85%D0%B5%D0%BC%D0%B0.png)

Схема работы:

![petri_db_replication](../media/petri_db-%D0%A0%D0%B5%D0%BF%D0%BB%D0%B8%D0%BA%D0%B0%D1%86%D0%B8%D1%8F.png)

```
1.Клиент -> Получение метаданных таблицы 1.table -> μ Ожидание • Проверить блокировку строки 1.table/1111 ->
    ( Ожидание
    | Заблокировать файл 2.table/1111 -> Получение метаданных файла 1.table/1111 -> Изменить файл 1.table/1111 -> 1.Получение адресов серверов, содержащих таблицу table -> Получение метаданных таблицы 2.table -> μ Ожидание • Проверить блокировку файла 2.table/1111 ->
        (Ожидание
        | Заблокировать файл 2.table/1111 -> Получение метаданных файла 2.table/1111 -> Изменить строку 2.table/1111 -> Разблокировать строку 2.table/1111 -> Разблокировать строку 1.table/1111)) -> 1.Клиент
```
Псевдо sql:
```sql
UPDATE `table`
SET vale = 2
WHERE id = 1;
```

```
2.Клиент -> Получение метаданных таблицы 2.table -> μ Ожидание • Проверить блокировку строки 1.table/1111 ->
    ( Ожидание
    | Заблокировать файл 2.table/1111 -> Получение метаданных файла 2.table/1111 -> Изменить файл 2.table/1111 -> 2.Получение адресов серверов, содержащих таблицу table -> Получение метаданных таблицы 1.table -> μ Ожидание • Проверить блокировку файла 1.table/1111 ->
        (Ожидание
        | Заблокировать файл 1.table/1111 -> Получение метаданных файла 1.table/1111 -> Изменить строку 1.table/1111 -> Разблокировать строку 1.table/1111 -> Разблокировать строку 2.table/1111)) -> 2.Клиент
```
Псевдо sql:
```sql
UPDATE `table`
SET vale = 1000
WHERE id = 1;
```

## Возможные условия блокировок, сводящиеся к тем что описаны
1. Цикличная блокировка трёх клиентов с захватом каждого одного из трёх разделяемых ресуров - сводится к задаче с блокировкой двух клиентов с двумя ресурсами.
2. Блокировка в пересекающихся диапазонах - диапазоны реализованы только в формати блокировки поддерева индексов. Блокировка диапазона индексов описана в соответсвующем примере.
3. Блокировка через эскалацию блокировки от части строк до всей таблицы на двух клиентах - сводится к блокировке двух клиентов с двумя ресурсам. Если всего разделяемых ресурса два, то захват одного потом второго эквиваленте захвату одного потом всей таблицы
4. Блокировка в связи с медленной репликацией данных между серверами - сводится к блоировкой со взаимной репликацией, так как кейс описан событийно без привязки к длительноти процессов.
5. Взаимоисключающие операции над одним и тем же значении (инкрементирование и одновременное декрементироваие ресурса) - Задача сводится к задачам с n клиентов и n операций. Если есть хоть два разделяемых ресурса, то при захвате обоих разными клиентами процессы будут заблокированны. Если ресурс один, то он будет доступен процессам ожидающим его, после окончания работы процесса что его захватил.
6. Удаление таблицы одним клиентом перед захватом строки в ней другим - совпадает с примером изменения прав доступа, так как в обоих случаях у клиента полностью пропадает доступ к одному из требуемых разделяемых реурсов.