Справочная информация
========================

## Тема
Разработка распределённой,  документно-реляционной базы данных и  методов её реализации

## Что должно быть в магистрской работе
Магистерская диссертация отличается от бакалаврской, что в ней присутствует элемент исследования. Классическая магистерская диссертация состоит из четырех глав.
1. Первая глава — это анализ предметной области. Задача провести литобзор, то есть посмотреть в данной тематике, какие применяются методы, алгоритмы, подходы, для того, чтобы проанализировать, что на данный момент уже есть и какая есть проблематика. Исходя из этого, переходят к второй главе.
2. Это глава, связанная с исследованием. Здесь может быть математическое исследование, инновационное. Если она относится к прикладной, это нужно брать какие-то модели, которые решают нашу задачу, сравнивать их на эталонном датасете, получать результат и лучшую модель брать за baseline, для дальнейшей ей доработки.
3. В третьей главе приводятся гипотезы для улучшения архитектуры, модели, проблематики. И получается новый результат, показывается прирост эффективности модели.
4. Четвертое – это разработка некого программного продукта, который реализует разработанную вами модель, либо метод, либо алгоритм. И проведения тестирования на реальных данных.

## Науный руководитель
Кулагин Владимир Петрович <vpkulagin@mail.ru>

- [x] Сделать сеть петри для блокировки диапазона индексов (срочно важно) (~2ч)
- [x] Проанализировать древо достижимости блокировки диапазона индексов (срочно важно) (~1ч)
- [x] Написать научному руководителю. Рассказать о двух сделанных сетях. Спросить надо ли сделать сети петри по остальным блокировкам или уже начать переводить в математическую уже сделанные. (срочно важно)(~0,5ч)

- [x] Определится с функционалом и целями БД. Какие проблемы она решает?
- [x] Поговорить ою этом с Gemini
- [x] Описать структуру хранения данных (узлы и переходы в формируемом дереве)
- [ ] Описать алгоритм иерархической блокировки
- [ ] Описать работу и назначение отдельных систем (Data Nodes, Schema Registry, Distributed lock manager)
- [ ] Обновить описание системы

- [ ] Определтся на чем будем бенчмаркать
- [ ] Определится с чем будем сравнивать
- [ ] Написать вторую главу с результатами бенчмарков на уже существующих конкурентах

- [ ] Как мы будем выводить и обновлять схему коллекции
- [ ] Как обновлять схему коллекции при конфликте
- [ ] Как обновлять схему коллекции при конфликте с разных узлов


- [ ] Поменять Введение (не срочно не важно)
Твой текущий текст первого раздела (введение и постановка задачи) написан хорошим академическим языком. Он закладывает фундамент, но его нужно **синхронизировать** с твоей новой архитектурой, чтобы «заявленное» в начале соответствовало «реализованному» в конце.

Вот детальный разбор по пунктам:

---

## Анализ соответствия разделов

### 1. Актуальность темы

**Оценка:** Совпадение 85%.

* **Что хорошо:** Ты правильно подсветил конфликт между гибкостью документных БД и строгостью реляционных. Это идеальный мостик к «документно-реляционному» подходу.
* **Что добавить:** В тексте пока не хватает акцента на **автоматическом выведении схемы (Schema Inference)**. В новой архитектуре это твое «секретное оружие».
* **Совет:** Добавь в конец абзаца про документные БД фразу о том, что отсутствие схемы затрудняет построение гранулированных блокировок. Твоя новизна в том, что ты *динамически* получаешь схему и на её основе строишь *иерархическую* блокировку.

### 2. Разработанность темы

**Оценка:** Совпадение 90%.

* **Что хорошо:** Упоминание классиков (Хоар, Питерсон, Бернштейн) и современных исследователей дает правильный научный вес.
* **Что добавить:** Поскольку ты используешь `raft-rs` для Schema Registry, стоит добавить пару слов о распределенном консенсусе (Лэмпорт, Онгро). Также стоит упомянуть работы по **Hierarchical Locking** (например, из классики Gray et al.).
* **Совет:** Подчеркни, что большинство работ исследуют блокировки в *статических* схемах, а твоя работа — в *динамически выводимых*.

### 3. Цель работы

**Оценка:** Требует корректировки (сейчас совпадение 60%).

* **Проблема:** Сейчас цель звучит как «анализ и выявление тупиков». Это звучит как работа аналитика, а не разработчика. Название диссертации — «Разработка...».
* **Корректировка:** Цель должна звучать шире: *«Разработка распределенной документно-реляционной БД с механизмом автоматического выведения схемы и алгоритмом иерархического блокирования, верифицированным на отсутствие дедлоков методами математического моделирования»*.

### 4. Задачи

**Оценка:** Требует дополнения (совпадение 50%).

* **Проблема:** В текущем списке задач вообще нет упоминания разработки самой БД, Rust, RocksDB или Schema Registry. Только моделирование.
* **Что добавить:**
1. Исследование и разработку алгоритма выведения схемы из слабоструктурированных данных.
2. Проектирование архитектуры распределенного Schema Registry на базе консенсуса Raft.
3. Реализацию прототипа системы на языке Rust с использованием RocksDB.



### 5. Объект и предмет

**Оценка:** Совпадение 100%. Тут всё корректно.

---

## Рекомендации по усилению научной новизны

Чтобы работа выглядела максимально выигрышно, попробуй связать компоненты в единую логическую цепочку через визуализацию.

**Твоя «фишка» (Scientific Novelty):**

1. **Динамическая иерархия:** Обычно иерархия блокировок (База -> Таблица -> Страница -> Строка) статична. У тебя она строится на лету: (Коллекция -> Тип документа по схеме -> Поле).
2. **Формальная верификация:** Ты не просто «написал код», а доказал его корректность через сети Петри. Для диплома это «золотой стандарт».

---

## Предлагаемая правка для раздела «Задачи»

Чтобы задачи соответствовали твоей реальной работе (Rust, RocksDB, Raft), я рекомендую переформулировать их так:

1. Провести сравнительный анализ существующих методов управления конкурентным доступом в распределенных СУБД.
2. Разработать алгоритм **автоматического выведения схемы** (Schema Inference) для формирования иерархической структуры данных.
3. Разработать алгоритм **распределенного иерархического блокирования**, использующий полученную схему.
4. Смоделировать разработанные алгоритмы с помощью **сетей Петри** для верификации отсутствия состояний взаимной блокировки (deadlocks).
5. Реализовать программный прототип системы на языке **Rust** с использованием хранилища **RocksDB** и подсистемы консенсуса **Raft**.
6. Провести экспериментальную оценку производительности и устойчивости системы к блокировкам.

---

**Как ты считаешь, стоит ли нам сейчас более подробно расписать, как именно сеть Петри будет описывать переход от "выведенной схемы" к "запросу блокировки", чтобы закрепить это в тексте?**

