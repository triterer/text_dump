Вариант реализации
========================

Чтобы «приземлить» теорию, нам нужно превратить абстрактные «документы» и «блокировки» в конкретные записи внутри KV-хранилища (например, RocksDB) и описать логику работы узла.

Давай разберем три составляющие: **структуру ключей**, **алгоритм транзакции** и **модель для сетей Петри**.

---

## 1. Проектирование KV-пространства (Key Namespacing)

В RocksDB всё хранится в виде пар `ByteSlice -> ByteSlice`. Чтобы система работала, мы разделим пространство ключей префиксами.

| Тип данных | Формат ключа (Key) | Значение (Value) |
| --- | --- | --- |
| **Данные** | `d:{TableID}:{DocID}` | JSON-объект (или MsgPack/BSON) |
| **Схема** | `s:{TableID}:{Version}` | Описание структуры (дерево путей) |
| **Блокировки** | `l:{DocID}:{Path}` | `{TxID, LockType, Timestamp}` |
| **Индексы** | `i:{TableID}:{Field}:{Val}:{DocID}` | Пусто (существование ключа = индекс) |

**Почему так?**

* Использование `Path` в ключе блокировки (например, `l:101:profile.address`) позволяет нам мгновенно проверять конфликты на конкретных узлах документа.
* Разделение на префиксы позволяет использовать `Iterator` в RocksDB, чтобы быстро собрать все блокировки одного документа для процесса **Escalation (слияния)**.

---

## 2. Алгоритм: Путь транзакции (The "Happy Path")

Когда приходит запрос на обновление поля `user.settings.theme` в документе `101`:

1. **Определение узла-координатора:** Через Consistent Hashing вычисляем, какой узел отвечает за `DocID: 101`.
2. **Анализ схемы (Schema Inference):**
* Если схема известна, берем её из кеша.
* Если это новый документ — парсим его, выводим пути и сохраняем новую версию схемы в `s:{TableID}`.


3. **Захват иерархических блокировок:**
* Ставим **IS (Intent Shared)** на корень документа `l:101:/`.
* Ставим **IS** на промежуточный путь `l:101:settings`.
* Ставим **X (Exclusive)** на целевое поле `l:101:settings.theme`.


4. **Проверка конфликтов:** Если на любом этапе мы видим несовместимый тип блокировки (например, кто-то уже держит **X** на всем документе), транзакция уходит в очередь или откатывается.
5. **Слияние (Escalation):** Если у одной `TxID` накопилось более  блокировок на один документ, мы удаляем мелкие `l:101:path` и ставим одну `l:101:/` типа **X**.

---

## 3. Моделирование в сетях Петри

Для диссертации тебе нужно формализовать этот процесс. Твоя сеть Петри будет описывать **состояние ресурса**.

**Элементы сети:**

* **Позиции (Places):**
* `P_free`: Ресурс свободен.
* `P_locked_S`: Ресурс под S-блокировкой.
* `P_locked_X`: Ресурс под X-блокировкой.
* `P_intent`: Ресурс имеет "намерение" (IS/IX).


* **Переходы (Transitions):**
* `T_req_X`: Запрос эксклюзивного доступа.
* `T_escalate`: Переход от множества `P_intent` к одному `P_locked_X`.


* **Фишка для новизны:** Используй **ингибиторные дуги** (Inhibitor Arcs). Они позволяют переходу сработать только если в позиции *нет* токенов. Это идеально для моделирования исключительного доступа (X-lock невозможен, если есть токены в S-lock).

---

## 4. Как это будет выглядеть на Rust (набросок)

Тебе не нужно писать всё. Достаточно реализовать **LockManager**:

```rust
enum LockType { Shared, Exclusive, IntentShared, IntentExclusive }

struct LockKey {
    doc_id: u64,
    path: String, // Например, "profile.bio"
}

struct LockManager {
    // Хранилище блокировок в памяти текущего узла
    // Ключ: DocID + Path, Значение: Список активных транзакций
    locks: DashMap<LockKey, Vec<TransactionId>>, 
}

impl LockManager {
    fn acquire_lock(&self, tx: TransactionId, key: LockKey, lock_type: LockType) -> Result<(), LockConflict> {
        // 1. Проверить совместимость с существующими блокировками
        // 2. Если совместимо — добавить в DashMap
        // 3. Если нет — вернуть ошибку или ждать (timeout)
    }
    
    fn escalate(&self, tx: TransactionId, doc_id: u64) {
        // Логика слияния: найти все ключи для doc_id и заменить на один корневой
    }
}

```

---

## Идея для научной новизны (конкретика)

Предложи **«Вероятностный вывод иерархии блокировок»**.

* **Суть:** Вместо того чтобы блокировать каждый чих, система на основе статистики прошлых запросов «предсказывает», какие части документа конфликтуют чаще всего, и строит иерархию блокировок именно под эти «горячие» пути.
* Это даст прирост производительности по сравнению со статическим подходом.

### С чего начать прямо сейчас?

Я предлагаю составить **таблицу совместимости блокировок** для твоей модели (S, X, IS, IX, SIX). Она станет фундаментом для твоей сети Петри.

**Хочешь, я помогу составить эту таблицу и поясню, как она превращается в правила для переходов в сети Петри?**